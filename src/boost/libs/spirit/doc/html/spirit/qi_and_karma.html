<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Qi and Karma</title>
<link rel="stylesheet" href="../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.66.1">
<link rel="start" href="../index.html" title="Spirit 2.0">
<link rel="up" href="../index.html" title="Spirit 2.0">
<link rel="prev" href="introduction.html" title="Introduction">
<link rel="next" href="qi_and_karma/abstracts.html" title="Abstracts">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="qi_and_karma/abstracts.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="spirit.qi_and_karma"></a><a href="qi_and_karma.html" title="Qi and Karma">Qi and Karma</a></h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials">Tutorials</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.quick_start">Quick Start</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.warming_up">Warming up</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.semantic_actions">Semantic
        Actions</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.complex___our_first_complex_parser">Complex
        - Our first complex parser</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.sum___adding_numbers">Sum
        - adding numbers</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.number_list___stuffing_numbers_into_a_std__vector">Number
        List - stuffing numbers into a std::vector</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.number_list_redux___list_syntax">Number
        List Redux - list syntax</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.number_list_attribute___one_more__with_style">Number
        List Attribute - one more, with style</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.roman_numerals">Roman
        Numerals</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs">Employee
        - Parsing into structs</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_">Mini
        XML - ASTs!</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___error_handling">Mini
        XML - Error Handling</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="qi_and_karma/abstracts.html">Abstracts</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="qi_and_karma/abstracts.html#spirit.qi_and_karma.abstracts.parsing_expression_grammar">Parsing
        Expression Grammar</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/parsing.html">Parsing</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/parsing_and_generating.html">Parsing
        and Generating</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/primitives.html">Primitives</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/operators.html">Operators</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/attributes.html">Attributes</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/semantic_actions.html">Semantic
        Actions</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/directives.html">Directives</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/rules.html">Rules</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/grammars.html">Grammars</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/debugging.html">Debugging</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/mini_xml___error_handling.html">Mini
        XML - Error Handling</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/abstracts/parse_trees_and_asts.html">Parse
        Trees and ASTs</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="qi_and_karma/quick_reference.html">Quick Reference</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference.html">Reference</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="qi_and_karma/reference.html#spirit.qi_and_karma.reference.concepts">Concepts</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/char.html">Char</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/string.html">String</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/numeric.html">Numeric</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/binary.html">Binary</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/directive.html">Directive</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/action.html">Action</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/nonterminal.html">Nonterminal</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/operators.html">Operators</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/stream.html">Stream</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/auxiliary.html">Auxiliary</a></span></dt>
<dt><span class="section"><a href="qi_and_karma/reference/debug.html">Debug</a></span></dt>
</dl></dd>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="spirit.qi_and_karma.tutorials"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials" title="Tutorials">Tutorials</a></h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.quick_start">Quick Start</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.warming_up">Warming up</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.semantic_actions">Semantic
        Actions</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.complex___our_first_complex_parser">Complex
        - Our first complex parser</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.sum___adding_numbers">Sum
        - adding numbers</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.number_list___stuffing_numbers_into_a_std__vector">Number
        List - stuffing numbers into a std::vector</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.number_list_redux___list_syntax">Number
        List Redux - list syntax</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.number_list_attribute___one_more__with_style">Number
        List Attribute - one more, with style</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.roman_numerals">Roman
        Numerals</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs">Employee
        - Parsing into structs</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_">Mini
        XML - ASTs!</a></span></dt>
<dt><span class="section"><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___error_handling">Mini
        XML - Error Handling</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.quick_start"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.quick_start" title="Quick Start">Quick Start</a></h4></div></div></div>
<a name="spirit.qi_and_karma.tutorials.quick_start.why_would_you_want_to_use_spirit_qi_"></a><h5>
<a name="id460252"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.quick_start.why_would_you_want_to_use_spirit_qi_">Why
          would you want to use Spirit.Qi?</a>
        </h5>
<p>
          Spirit.Qi is designed to be a practical parsing tool. The ability to generate
          a fully-working parser from a formal EBNF specification inlined in C++
          significantly reduces development time. Programmers typically approach
          parsing using ad hoc hacks with primitive tools such as scanf. Even regular-expression
          libraries (such as boost regex) or scanners (such as Boost tokenizer) do
          not scale well when we need to write more elaborate parsers. Attempting
          to write even a moderately-complex parser using these tools leads to code
          that is hard to understand and maintain.
        </p>
<p>
          One prime objective is to make the tool easy to use. When one thinks of
          a parser generator, the usual reaction is "it must be big and complex
          with a steep learning curve." Not so. Spirit is designed to be fully
          scalable. The framework is structured in layers. This permits learning
          on an as-needed basis, after only learning the minimal core and basic concepts.
        </p>
<p>
          For development simplicity and ease in deployment, the entire framework
          consists of only header files, with no libraries to link against or build.
          Just put the spirit distribution in your include path, compile and run.
          Code size? -very tight -essentially comparable to hand written recursive
          descent code.
        </p>
<p>
          Our tutorials will walk you through the simplest Spirit examples, incrementally
          building on top of the earlier examples as we expose more and more features
          and techniques. We will try to be as gentle as possible with the learning
          curve. We will present the tutorials in a cookbook style approach. This
          style of presentation is based on our BoostCon '07 and BoostCon '08 slides.
        </p>
<p>
          Have fun!
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.warming_up"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.warming_up" title="Warming up">Warming up</a></h4></div></div></div>
<p>
          We'll start by showing examples of parser expressions to give you a feel
          on how to build parsers from the simplest parser, building up as we go.
        </p>
<a name="spirit.qi_and_karma.tutorials.warming_up.trivial_example__1_parsing_a_number"></a><h5>
<a name="id460361"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.warming_up.trivial_example__1_parsing_a_number">Trivial
          Example #1 Parsing a number</a>
        </h5>
<p>
          Create a parser that will parse a floating-point number.
        </p>
<pre class="programlisting"><span class="identifier">double_</span>
</pre>
<p>
          (You've got to admit, that's trivial!) The above code actually generates
          a Spirit floating point parser (a built-in parser). Spirit has many pre-defined
          parsers and consistent naming conventions help you keep from going insane!
        </p>
<a name="spirit.qi_and_karma.tutorials.warming_up.trivial_example__2_parsing_two_numbers"></a><h5>
<a name="id460416"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.warming_up.trivial_example__2_parsing_two_numbers">Trivial
          Example #2 Parsing two numbers</a>
        </h5>
<p>
          Create a parser that will accept a line consisting of two floating-point
          numbers.
        </p>
<pre class="programlisting"><span class="identifier">double_</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span>
</pre>
<p>
          Here you see the familiar floating-point numeric parser <tt class="computeroutput"><span class="identifier">double_</span></tt>
          used twice, once for each number. What's that <tt class="computeroutput"><span class="special">&gt;&gt;</span></tt>
          operator doing in there? Well, they had to be separated by something, and
          this was chosen as the "followed by" sequence operator. The above
          program creates a parser from two simpler parsers, glueing them together
          with the sequence operator. The result is a parser that is a composition
          of smaller parsers. Whitespace between numbers can implicitly be consumed
          depending on how the parser is invoked (see below).
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
            When we combine parsers, we end up with a "bigger" parser,
            but it's still a parser. Parsers can get bigger and bigger, nesting more
            and more, but whenever you glue two parsers together, you end up with
            one bigger parser. This is an important concept.
          </p></td></tr>
</table></div>
<a name="spirit.qi_and_karma.tutorials.warming_up.trivial_example__3_parsing_one_or_more_numbers"></a><h5>
<a name="id460526"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.warming_up.trivial_example__3_parsing_one_or_more_numbers">Trivial
          Example #3 Parsing one or more numbers</a>
        </h5>
<p>
          Create a parser that will accept one or more floating-point numbers.
        </p>
<pre class="programlisting"><span class="special">*</span><span class="identifier">double_</span>
</pre>
<p>
          This is like a regular-expression Kleene Star, though the syntax might
          look a bit odd for a C++ programmer not used to seeing the <tt class="computeroutput"><span class="special">*</span></tt> operator overloaded like this. Actually,
          if you know regular expressions it may look odd too since the star is before
          the expression it modifies. C'est la vie. Blame it on the fact that we
          must work with the syntax rules of C++.
        </p>
<p>
          Any expression that evaluates to a parser may be used with the Kleene Star.
          Keep in mind, though, that due to C++ operator precedence rules you may
          need to put the expression in parentheses for complex expressions. The
          Kleene Star is also known as a Kleene Closure, but we call it the Star
          in most places.
        </p>
<a name="spirit.qi_and_karma.tutorials.warming_up.trivial_example__4_parsing_a_comma_delimited_list_of_numbers"></a><h5>
<a name="id460609"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.warming_up.trivial_example__4_parsing_a_comma_delimited_list_of_numbers">Trivial
          Example #4 Parsing a comma-delimited list of numbers</a>
        </h5>
<p>
          This example will create a parser that accepts a comma-delimited list of
          numbers.
        </p>
<pre class="programlisting"><span class="identifier">double_</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="identifier">char_</span><span class="special">(</span><span class="char">','</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">)</span>
</pre>
<p>
          Notice <tt class="computeroutput"><span class="identifier">char_</span><span class="special">(</span><span class="char">','</span><span class="special">)</span></tt>. It is
          a literal character parser that can recognize the comma <tt class="computeroutput"><span class="char">','</span></tt>.
          In this case, the Kleene Star is modifying a more complex parser, namely,
          the one generated by the expression:
        </p>
<pre class="programlisting"><span class="special">(</span><span class="identifier">char_</span><span class="special">(</span><span class="char">','</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">)</span>
</pre>
<p>
          Note that this is a case where the parentheses are necessary. The Kleene
          star encloses the complete expression above.
        </p>
<a name="spirit.qi_and_karma.tutorials.warming_up.let_s_parse_"></a><h5>
<a name="id460803"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.warming_up.let_s_parse_">Let's
          Parse!</a>
        </h5>
<p>
          We're done with defining the parser. So the next step is now invoking this
          parser to do its work. There are a couple of ways to do this. For now,
          we will use the <tt class="computeroutput"><span class="identifier">phrase_parse</span></tt>
          function. One overload of this function accepts four arguments:
        </p>
<div class="orderedlist"><ol type="1">
<li>
            An iterator pointing to the start of the input
          </li>
<li>
            An iterator pointing to one past the end of the input
          </li>
<li>
            The parser object
          </li>
<li>
            Another parser called the skip parser
          </li>
</ol></div>
<p>
          In our example, we wish to skip spaces and tabs. Another parser named
          <tt class="computeroutput"><span class="identifier">space</span></tt> is included in Spirit's
          repertoire of predefined parsers. It is a very simple parser that simply
          recognizes whitespace. We will use <tt class="computeroutput"><span class="identifier">space</span></tt>
          as our skip parser. The skip parser is the one responsible for skipping
          characters in between parser elements such as the <tt class="computeroutput"><span class="identifier">double_</span></tt>
          and <tt class="computeroutput"><span class="identifier">char_</span></tt>.
        </p>
<p>
          Ok, so now let's parse!
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">parse_numbers</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">last</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">phrase_parse</span><span class="special">(</span>
        <span class="identifier">first</span><span class="special">,</span>                          <span class="callout_bug"><a name="spirit0co" href="qi_and_karma.html#spirit0"><img src="../images/callouts/1.png" alt="1" border="0"></a></span>
        <span class="identifier">last</span><span class="special">,</span>                           <span class="callout_bug"><a name="spirit1co" href="qi_and_karma.html#spirit1"><img src="../images/callouts/2.png" alt="2" border="0"></a></span>
        <span class="identifier">double_</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="char">','</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">),</span>   <span class="callout_bug"><a name="spirit2co" href="qi_and_karma.html#spirit2"><img src="../images/callouts/3.png" alt="3" border="0"></a></span>
        <span class="identifier">space</span>                           <span class="callout_bug"><a name="spirit3co" href="qi_and_karma.html#spirit3"><img src="../images/callouts/4.png" alt="4" border="0"></a></span>
    <span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">last</span><span class="special">)</span> <span class="comment">// fail if we did not get a full match
</span>        <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">r</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
          </p>
<p>
            </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="spirit0"></a><a href="#spirit0co"><img src="../images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> start iterator </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="spirit1"></a><a href="#spirit1co"><img src="../images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> end iterator </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="spirit2"></a><a href="#spirit2co"><img src="../images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> the parser </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="spirit3"></a><a href="#spirit3co"><img src="../images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> the skip-parser </p></td>
</tr>
</table></div>
<p>
          </p>
<p>
        </p>
<p>
          The parse function returns <tt class="computeroutput"><span class="keyword">true</span></tt>
          or <tt class="computeroutput"><span class="keyword">false</span></tt> depending on the
          result of the parse. The first iterator is passed by reference. On a successful
          parse, this iterator is repositioned to the rightmost position consumed
          by the parser. If this becomes equal to str.end(), then we have a full
          match. If not, then we have a partial match. A partial match happens when
          the parser is only able to parse a portion of the input.
        </p>
<p>
          Note that we inlined the parser directly in the call to parse. Upon calling
          parse, the expression evaluates into a temporary, unnamed parser which
          is passed into the parse() function, used, and then destroyed.
        </p>
<p>
          Here, we opted to make the parser generic by making it a template, parameterized
          by the iterator type. By doing so, it can take in data coming from any
          STL conforming sequence as long as the iterators conform to a forward iterator.
        </p>
<p>
          You can find the full cpp file here: <a href="../../../example/qi/num_list1.cpp" target="_top">../../example/qi/num_list1.cpp</a>
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top">
<p>
            <tt class="computeroutput"><span class="keyword">char</span></tt> and <tt class="computeroutput"><span class="keyword">wchar_t</span></tt>
            operands
          </p>
<p>
            The careful reader may notice that the parser expression has <tt class="computeroutput"><span class="char">','</span></tt> instead of <tt class="computeroutput"><span class="identifier">char_</span><span class="special">(</span><span class="char">','</span><span class="special">)</span></tt>
            as the previous examples did. This is ok due to C++ syntax rules of conversion.
            There are <tt class="computeroutput"><span class="special">&gt;&gt;</span></tt> operators
            that are overloaded to accept a <tt class="computeroutput"><span class="keyword">char</span></tt>
            or <tt class="computeroutput"><span class="keyword">wchar_t</span></tt> argument on its
            left or right (but not both). An operator may be overloaded if at least
            one of its parameters is a user-defined type. In this case, the <tt class="computeroutput"><span class="identifier">double_</span></tt> is the 2nd argument to <tt class="computeroutput"><span class="keyword">operator</span><span class="special">&gt;&gt;</span></tt>,
            and so the proper overload of <tt class="computeroutput"><span class="special">&gt;&gt;</span></tt>
            is used, converting <tt class="computeroutput"><span class="char">','</span></tt> into
            a character literal parser.
          </p>
<p>
            The problem with omiting the <tt class="computeroutput"><span class="identifier">char_</span></tt>
            should be obvious: <tt class="computeroutput"><span class="char">'a'</span> <span class="special">&gt;&gt;</span>
            <span class="char">'b'</span></tt> is not a spirit parser, it is
            a numeric expression, right-shifting the ASCII (or another encoding)
            value of <tt class="computeroutput"><span class="char">'a'</span></tt> by the ASCII value
            of <tt class="computeroutput"><span class="char">'b'</span></tt>. However, both <tt class="computeroutput"><span class="identifier">char_</span><span class="special">(</span><span class="char">'a'</span><span class="special">)</span> <span class="special">&gt;&gt;</span>
            <span class="char">'b'</span></tt> and <tt class="computeroutput"><span class="char">'a'</span>
            <span class="special">&gt;&gt;</span> <span class="identifier">char_</span><span class="special">(</span><span class="char">'b'</span><span class="special">)</span></tt>
            are Spirit sequence parsers for the letter <tt class="computeroutput"><span class="char">'a'</span></tt>
            followed by <tt class="computeroutput"><span class="char">'b'</span></tt>. You'll get
            used to it, sooner or later.
          </p>
</td></tr>
</table></div>
<p>
          Finally, take note that we test for a full match (i.e. the parser fully
          parsed the input) by checking if the first iterator, after parsing, is
          equal to the end iterator. You may strike out this part if partial matches
          are to be allowed.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.semantic_actions"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.semantic_actions" title="Semantic
        Actions">Semantic
        Actions</a></h4></div></div></div>
<p>
          Our parser above is really nothing but a recognizer. It answers the question
          "did the input match our grammar?", but it does not do anything
          other than that. It does not extract any information from what was parsed.
          For example, whenever we parse a real number, we wish to store the parsed
          number after a successful match.
        </p>
<p>
          Enter Semantic actions. Semantic actions may be attached to any point in
          the grammar specification. These actions are C++ functions or function
          objects that are called whenever a part of the parser successfully recognizes
          a portion of the input. Say you have a parser <tt class="computeroutput"><span class="identifier">P</span></tt>,
          and a C++ function <tt class="computeroutput"><span class="identifier">F</span></tt>, you
          can make the parser call <tt class="computeroutput"><span class="identifier">F</span></tt>
          whenever it matches an input by attaching <tt class="computeroutput"><span class="identifier">F</span></tt>:
        </p>
<pre class="programlisting"><span class="identifier">P</span><span class="special">[</span><span class="identifier">F</span><span class="special">]</span>
</pre>
<p>
          The expression above links <tt class="computeroutput"><span class="identifier">F</span></tt>
          to the parser, <tt class="computeroutput"><span class="identifier">P</span></tt>.
        </p>
<p>
          The function/function object signature depends on the type of the parser
          to which it is attached. The parser <tt class="computeroutput"><span class="identifier">double_</span></tt>
          passes the parsed number. Thus, if we were to attach a function <tt class="computeroutput"><span class="identifier">F</span></tt> to <tt class="computeroutput"><span class="identifier">double_</span></tt>,
          we need <tt class="computeroutput"><span class="identifier">F</span></tt> to be declared
          as:
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">F</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">n</span><span class="special">);</span>
</pre>
<p>
          There are actually 2 more arguments being passed (the parser context and
          a reference to a boolean 'hit' parameter). We don't need these, for now,
          but we'll see more on these other arguments later. Spirit.Qi allows us
          to bind a single argument function, like above. The other arguments are
          simply ignored.
        </p>
<p>
          Presented are various ways to attach semantic actions:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            Using plain function pointer
          </li>
<li>
            Using simple function object
          </li>
<li>
            Using <a href="http://www.boost.org/libs/bind/index.html" target="_top">Boost.Bind</a>
            with a plain function
          </li>
<li>
            Using <a href="http://www.boost.org/libs/bind/index.html" target="_top">Boost.Bind</a>
            with a member function
          </li>
<li>
            Using <a href="http://www.boost.org/libs/lambda/index.html" target="_top">Boost.Lambda</a>
</li>
</ul></div>
<p>
          Given:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="comment">// A plain function
</span><span class="keyword">void</span> <span class="identifier">write</span><span class="special">(</span><span class="keyword">int</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">i</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">// A member function
</span><span class="keyword">struct</span> <span class="identifier">writer</span>
<span class="special">{</span>
    <span class="keyword">void</span> <span class="identifier">print</span><span class="special">(</span><span class="keyword">int</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">i</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// A function object
</span><span class="keyword">struct</span> <span class="identifier">write_action</span>
<span class="special">{</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">i</span><span class="special">,</span> <span class="identifier">unused_type</span><span class="special">,</span> <span class="identifier">unused_type</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Take note that with function objects, we need to have an <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>
          with 3 arguments. Since we don't care about the other two, we can use
          <tt class="computeroutput"><span class="identifier">unused_type</span></tt> for these.
          We'll see more of <tt class="computeroutput"><span class="identifier">unused_type</span></tt>
          elsewhere. Get used to it. <tt class="computeroutput"><span class="identifier">unused_type</span></tt>
          is a Spirit supplied support class.
        </p>
<p>
          All examples parse inputs of the form:
        </p>
<pre class="programlisting"><span class="string">"{integer}"</span>
</pre>
<p>
          An integer inside the curly braces.
        </p>
<p>
          The first example shows how to attach a plain function:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="identifier">qi</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span> <span class="char">'{'</span> <span class="special">&gt;&gt;</span> <span class="identifier">int_</span><span class="special">[&amp;</span><span class="identifier">write</span><span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'}'</span><span class="special">);</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          What's new? Well <tt class="computeroutput"><span class="identifier">int_</span></tt> is
          the sibbling of <tt class="computeroutput"><span class="identifier">double_</span></tt>.
          I'm sure you can guess what this parser does.
        </p>
<p>
          The next example shows how to attach a simple function object:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="identifier">qi</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span> <span class="char">'{'</span> <span class="special">&gt;&gt;</span> <span class="identifier">int_</span><span class="special">[</span><span class="identifier">write_action</span><span class="special">()]</span> <span class="special">&gt;&gt;</span> <span class="char">'}'</span><span class="special">);</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          We can use <a href="http://www.boost.org/libs/bind/index.html" target="_top">Boost.Bind</a>
          to 'bind' member functions:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="identifier">writer</span> <span class="identifier">w</span><span class="special">;</span>
<span class="identifier">qi</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span> <span class="char">'{'</span> <span class="special">&gt;&gt;</span> <span class="identifier">int_</span><span class="special">[</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">writer</span><span class="special">::</span><span class="identifier">print</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">w</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">)]</span> <span class="special">&gt;&gt;</span> <span class="char">'}'</span><span class="special">);</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Likewise, we can also use <a href="http://www.boost.org/libs/bind/index.html" target="_top">Boost.Bind</a>
          to 'bind' plain functions:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="identifier">qi</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span> <span class="char">'{'</span> <span class="special">&gt;&gt;</span> <span class="identifier">int_</span><span class="special">[</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">write</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">)]</span> <span class="special">&gt;&gt;</span> <span class="char">'}'</span><span class="special">);</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Yep, we can also use <a href="http://www.boost.org/libs/lambda/index.html" target="_top">Boost.Lambda</a>:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="identifier">qi</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span> <span class="char">'{'</span> <span class="special">&gt;&gt;</span> <span class="identifier">int_</span><span class="special">[</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">_1</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'}'</span><span class="special">);</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          There are more ways to bind semantic action functions, but the examples
          above are the most common. Attaching semantic actions is the first hurdle
          one has to tackle when getting started with parsing with Spirit. Familiarize
          yourself with this task and get intimate with the tools behind it such
          as <a href="http://www.boost.org/libs/bind/index.html" target="_top">Boost.Bind</a>
          and <a href="http://www.boost.org/libs/lambda/index.html" target="_top">Boost.Lambda</a>.
        </p>
<p>
          The examples above can be found here: <a href="../../../example/qi/actions.cpp" target="_top">../../example/qi/actions.cpp</a>
        </p>
<a name="spirit.qi_and_karma.tutorials.semantic_actions.phoenix"></a><h5>
<a name="id463328"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.semantic_actions.phoenix">Phoenix</a>
        </h5>
<p>
          <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a>, a companion
          library bundled with Spirit, is specifically suited for binding semantic
          actions. It is like <a href="http://www.boost.org/libs/lambda/index.html" target="_top">Boost.Lambda</a>
          in steroids, with special custom features that make it easy to integrate
          semantic actions with Spirit. If your requirements go beyond simple to
          moderate parsing, I suggest you use this library. Examples presented henceforth
          shall be using the library exclusively
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.complex___our_first_complex_parser"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.complex___our_first_complex_parser" title="Complex
        - Our first complex parser">Complex
        - Our first complex parser</a></h4></div></div></div>
<p>
          Well, not really a complex parser, but a parser that parses complex numbers.
          This time, we're using <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a>
          to do the semantic actions.
        </p>
<p>
          Here's a simple parser expression for complex numbers:
        </p>
<pre class="programlisting">    <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span> <span class="special">&gt;&gt;</span> <span class="special">-(</span><span class="char">','</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span>
<span class="special">|</span>   <span class="identifier">double_</span>
</pre>
<p>
          What's new? Well, we have:
        </p>
<div class="orderedlist"><ol type="1">
<li>
            Alternates: e.g. <tt class="computeroutput"><span class="identifier">a</span> <span class="special">|</span>
            <span class="identifier">b</span></tt>. Try <tt class="computeroutput"><span class="identifier">a</span></tt>
            first. If it succeeds, good. If not, try the next alternative, <tt class="computeroutput"><span class="identifier">b</span></tt>.
          </li>
<li>
            Optionals: e.g. -p. Match the parser p zero or one time.
          </li>
</ol></div>
<p>
          The complex parser presented above reads as:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            One or two real number in parantheses, separated by comma (the second
            number is optional)
          </li>
<li>
<span class="bold"><b>OR</b></span> a single real number.
          </li>
</ul></div>
<p>
          This parser can parse complex numbers of the form:
        </p>
<pre class="programlisting"><span class="special">(</span><span class="number">123.45</span><span class="special">,</span> <span class="number">987.65</span><span class="special">)</span>
<span class="special">(</span><span class="number">123.45</span><span class="special">)</span>
<span class="number">123.45</span>
</pre>
<p>
          Here goes, this time with actions:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">parse_complex</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&amp;</span> <span class="identifier">c</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">double</span> <span class="identifier">rN</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">;</span>
    <span class="keyword">double</span> <span class="identifier">iN</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">phrase_parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span>

        <span class="comment">//  Begin grammar
</span>        <span class="special">(</span>
                <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">rN</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
                    <span class="special">&gt;&gt;</span> <span class="special">-(</span><span class="char">','</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">iN</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">])</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span>
            <span class="special">|</span>   <span class="identifier">double_</span><span class="special">[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">rN</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
        <span class="special">),</span>
        <span class="comment">//  End grammar
</span>
        <span class="identifier">space</span><span class="special">);</span>

    <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">r</span> <span class="special">||</span> <span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">last</span><span class="special">)</span> <span class="comment">// fail if we did not get a full match
</span>        <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;(</span><span class="identifier">rN</span><span class="special">,</span> <span class="identifier">iN</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">r</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          The full cpp file for this example can be found here: <a href="../../../example/qi/complex_number.cpp" target="_top">../../example/qi/complex_number.cpp</a>
        </p>
<p>
          The <tt class="computeroutput"><span class="identifier">double_</span></tt> parser attaches
          this action:
        </p>
<pre class="programlisting"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span>
</pre>
<p>
          This assigns the parsed result (actually, the attribute of <tt class="computeroutput"><span class="identifier">double_</span></tt>) to n. <tt class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span></tt>
          tells Phoenix that <tt class="computeroutput"><span class="identifier">n</span></tt> is
          a mutable reference. <tt class="computeroutput"><span class="identifier">_1</span></tt>
          is a Phoenix placeholder for the parsed result attribute.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.sum___adding_numbers"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.sum___adding_numbers" title="Sum
        - adding numbers">Sum
        - adding numbers</a></h4></div></div></div>
<p>
          Here's a parser that sums a comma-separated list of numbers.
        </p>
<p>
          Ok we've glossed over some details in our previous examples. First, our
          includes:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">include</span><span class="special">/</span><span class="identifier">qi</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">include</span><span class="special">/</span><span class="identifier">phoenix_core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">include</span><span class="special">/</span><span class="identifier">phoenix_operator</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Then some using directives:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">phoenix</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">qi</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">ascii</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">arg_names</span><span class="special">;</span>
</pre>
<p>
          </p>
<p>
        </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Namespace
                </p>
                </th>
<th>
                <p>
                  Description
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  boost::phoenix
                </p>
                </td>
<td>
                <p>
                  All of phoenix
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  boost::spirit
                </p>
                </td>
<td>
                <p>
                  All of spirit
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  boost::spirit::qi
                </p>
                </td>
<td>
                <p>
                  All of spirit.qi
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  boost::spirit::ascii
                </p>
                </td>
<td>
                <p>
                  ASCII version of <tt class="computeroutput"><span class="identifier">char_</span></tt>
                  and all char related parsers. Other encodings are also provided
                  (e.g. also an ISO8859.1)
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  boost::spirit::arg_names
                </p>
                </td>
<td>
                <p>
                  Special phoenix placeholders for spirit
                </p>
                </td>
</tr>
</tbody>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
            If you feel uneasy with using whole namespaces, feel free to qualify
            your code, use namespace aliases, etc. For the purpose of this tutorial,
            we will be presenting unqualified names for both Spirit and <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a>.
            No worries, we will always present the full working code, so you won't
            get lost. In fact, all examples in this tutorial have a corresponding
            cpp file that QuickBook (the documentation tool we are using) imports
            in here as code snippets.
          </p></td></tr>
</table></div>
<p>
          Now the actual parser:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">adder</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">last</span><span class="special">,</span> <span class="keyword">double</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">phrase_parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span>

        <span class="comment">//  Begin grammar
</span>        <span class="special">(</span>
            <span class="identifier">double_</span><span class="special">[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="char">','</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">])</span>
        <span class="special">)</span>
        <span class="special">,</span>
        <span class="comment">//  End grammar
</span>
        <span class="identifier">space</span><span class="special">);</span>

    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">last</span><span class="special">)</span> <span class="comment">// fail if we did not get a full match
</span>        <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">r</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          The full cpp file for this example can be found here: <a href="../../../example/qi/actions.cpp" target="_top">../../example/qi/actions.cpp</a>
        </p>
<p>
          This is almost like our original numbers list example. We're incrementally
          building on top of our examples. This time though, like in the complex
          number example, we'll be adding the smarts. There's an accumulator (`double&amp;
          n) that adds the numbers parsed. On a successful parse, this number is
          the sum of all the parsed numbers.
        </p>
<p>
          The first <tt class="computeroutput"><span class="identifier">double_</span></tt> parser
          attaches this action:
        </p>
<pre class="programlisting"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span>
</pre>
<p>
          This assigns the parsed result (actually, the attribute of <tt class="computeroutput"><span class="identifier">double_</span></tt>) to <tt class="computeroutput"><span class="identifier">n</span></tt>.
          <tt class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span></tt> tells
          <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a> that <tt class="computeroutput"><span class="identifier">n</span></tt> is a mutable reference. <tt class="computeroutput"><span class="identifier">_1</span></tt> is a <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a>
          placeholder for the parsed result attribute.
        </p>
<p>
          The second <tt class="computeroutput"><span class="identifier">double_</span></tt> parser
          attaches this action:
        </p>
<pre class="programlisting"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">+=</span> <span class="identifier">_1</span>
</pre>
<p>
          So, subsequent numbers add into <tt class="computeroutput"><span class="identifier">n</span></tt>.
        </p>
<p>
          That wasn't too bad, was it :-) ?
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.number_list___stuffing_numbers_into_a_std__vector"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.number_list___stuffing_numbers_into_a_std__vector" title="Number
        List - stuffing numbers into a std::vector">Number
        List - stuffing numbers into a std::vector</a></h4></div></div></div>
<p>
          This sample demontrates a parser for a comma separated list of numbers.
          The numbers are inserted in a vector using phoenix.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">parse_numbers</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">phrase_parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span>

        <span class="comment">//  Begin grammar
</span>        <span class="special">(</span>
            <span class="identifier">double_</span><span class="special">[</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">v</span><span class="special">),</span> <span class="identifier">_1</span><span class="special">)]</span>
                <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="char">','</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">[</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">v</span><span class="special">),</span> <span class="identifier">_1</span><span class="special">)])</span>
        <span class="special">)</span>
        <span class="special">,</span>
        <span class="comment">//  End grammar
</span>
        <span class="identifier">space</span><span class="special">);</span>

    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">last</span><span class="special">)</span> <span class="comment">// fail if we did not get a full match
</span>        <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">r</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          The full cpp file for this example can be found here: <a href="../../../example/qi/num_list2.cpp" target="_top">../../example/qi/num_list2.cpp</a>
        </p>
<p>
          This, again, is the same parser as before. This time, instead of summing
          up the numbers, we stuff them in a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></tt>.
          <tt class="computeroutput"><span class="identifier">push_back</span></tt> is supplied by
          <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a>. The expression:
        </p>
<pre class="programlisting"><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">v</span><span class="special">),</span> <span class="identifier">_1</span><span class="special">)</span>
</pre>
<p>
          appends the parsed number. Like before, <tt class="computeroutput"><span class="identifier">_1</span></tt>
          is a <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a> placeholder
          for the parsed result attribute. Also, like before, <tt class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">v</span><span class="special">)</span></tt>
          tells <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a> that
          <tt class="computeroutput"><span class="identifier">v</span></tt>, the <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></tt>,
          is a mutable reference.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.number_list_redux___list_syntax"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.number_list_redux___list_syntax" title="Number
        List Redux - list syntax">Number
        List Redux - list syntax</a></h4></div></div></div>
<p>
          So far, we've been using the syntax:
        </p>
<pre class="programlisting"><span class="identifier">double_</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="char">','</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">)</span>
</pre>
<p>
          to parse a comma-delimited list of numbers. Such lists are common in parsing
          and Spirit provides a simpler shortcut for them. The expression above can
          be simplified to:
        </p>
<pre class="programlisting"><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span>
</pre>
<p>
          read as: a list of doubles separated by <tt class="computeroutput"><span class="char">','</span></tt>.
        </p>
<p>
          This sample, again a variation of our previous example, demonstrates just
          that:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">parse_numbers</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">phrase_parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span>

        <span class="comment">//  Begin grammar
</span>        <span class="special">(</span>
            <span class="identifier">double_</span><span class="special">[</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">v</span><span class="special">),</span> <span class="identifier">_1</span><span class="special">)]</span> <span class="special">%</span> <span class="char">','</span>
        <span class="special">)</span>
        <span class="special">,</span>
        <span class="comment">//  End grammar
</span>
        <span class="identifier">space</span><span class="special">);</span>

    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">last</span><span class="special">)</span> <span class="comment">// fail if we did not get a full match
</span>        <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">r</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          The full cpp file for this example can be found here: <a href="../../../example/qi/num_list3.cpp" target="_top">../../example/qi/num_list3.cpp</a>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.number_list_attribute___one_more__with_style"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.number_list_attribute___one_more__with_style" title="Number
        List Attribute - one more, with style">Number
        List Attribute - one more, with style</a></h4></div></div></div>
<p>
          You've seen that the <tt class="computeroutput"><span class="identifier">double_</span></tt>
          parser has a <tt class="computeroutput"><span class="keyword">double</span></tt> attribute.
          All parsers have an attribute, even complex parsers, those that are composed
          from primitives using operators, like the list parser, also have an attribute.
          It so happens that the the attribute of a list parser:
        </p>
<pre class="programlisting"><span class="identifier">p</span> <span class="special">%</span> <span class="identifier">d</span>
</pre>
<p>
          is a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></tt> of the attribute of <tt class="computeroutput"><span class="identifier">p</span></tt>. So, for our parser:
        </p>
<pre class="programlisting"><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span>
</pre>
<p>
          we'll have an attribute of:
        </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span>
</pre>
<p>
          So, what does this give us? Well, we can simply pass in a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></tt>
          to our number list parser and it will happily churn out our result in our
          vector. For that to happen, we'll use a variation of the <tt class="computeroutput"><span class="identifier">phrase_parse</span></tt> with an additional argument:
          the parser's attribute:
        </p>
<div class="orderedlist"><ol type="1">
<li>
            An iterator pointing to the start of the input
          </li>
<li>
            An iterator pointing to one past the end of the input
          </li>
<li>
            The parser object
          </li>
<li>
            The parser's attribute
          </li>
<li>
            Another parser called the skip parser
          </li>
</ol></div>
<p>
          So, our parser now is further simplified to:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">parse_numbers</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">phrase_parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span>

        <span class="comment">//  Begin grammar
</span>        <span class="special">(</span>
            <span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span>
        <span class="special">)</span>
        <span class="special">,</span>
        <span class="comment">//  End grammar
</span>
        <span class="identifier">v</span><span class="special">,</span> <span class="identifier">space</span><span class="special">);</span>

    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">last</span><span class="special">)</span> <span class="comment">// fail if we did not get a full match
</span>        <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">r</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          The full cpp file for this example can be found here: <a href="../../../example/qi/num_list4.cpp" target="_top">../../example/qi/num_list4.cpp</a>
        </p>
<p>
          <span class="bold"><b>Hey, no more actions!!!</b></span> Now we're entering
          the realm of attribute grammars. Cool eh?
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.roman_numerals"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.roman_numerals" title="Roman
        Numerals">Roman
        Numerals</a></h4></div></div></div>
<p>
          This example demonstrates:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            symbol table
          </li>
<li>
            rule
          </li>
<li>
            grammar
          </li>
</ul></div>
<a name="spirit.qi_and_karma.tutorials.roman_numerals.symbol_table"></a><h5>
<a name="id467678"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.roman_numerals.symbol_table">Symbol
          Table</a>
        </h5>
<p>
          The symbol table holds a dictionary of symbols where each symbol is a sequence
          of characters (a <tt class="computeroutput"><span class="keyword">char</span></tt>, <tt class="computeroutput"><span class="keyword">wchar_t</span></tt>, <tt class="computeroutput"><span class="keyword">int</span></tt>,
          enumeration etc.) . The template class, parameterized by the character
          type, can work efficiently with 8, 16, 32 and even 64 bit characters. Mutable
          data of type T is associated with each symbol.
        </p>
<p>
          Traditionally, symbol table management is maintained seperately outside
          the BNF grammar through semantic actions. Contrary to standard practice,
          the Spirit symbol table class symbols is-a parser. An object of which may
          be used anywhere in the EBNF grammar specification. It is an example of
          a dynamic parser. A dynamic parser is characterized by its ability to modify
          its behavior at run time. Initially, an empty symbols object matches nothing.
          At any time, symbols may be added or removed, thus, dynamically altering
          its behavior.
        </p>
<p>
          Each entry in a symbol table has an associated mutable data slot. In this
          regard, one can view the symbol table as an associative container (or map)
          of key-value pairs where the keys are strings.
        </p>
<p>
          The symbols class expects two template parameters. The first parameter
          specifies the character type of the symbols. The second specifies the data
          type associated with each symbol: its attribute.
        </p>
<p>
          Here's a parser for roman hundreds (100..900) using the symbol table. Keep
          in mind that the data associated with each slot is the parser's attribute
          (which is passed to attached semantic actions).
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">hundreds_</span> <span class="special">:</span> <span class="identifier">symbols</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span> <span class="keyword">unsigned</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">hundreds_</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">add</span>
            <span class="special">(</span><span class="string">"C"</span>    <span class="special">,</span> <span class="number">100</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"CC"</span>   <span class="special">,</span> <span class="number">200</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"CCC"</span>  <span class="special">,</span> <span class="number">300</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"CD"</span>   <span class="special">,</span> <span class="number">400</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"D"</span>    <span class="special">,</span> <span class="number">500</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"DC"</span>   <span class="special">,</span> <span class="number">600</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"DCC"</span>  <span class="special">,</span> <span class="number">700</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"DCCC"</span> <span class="special">,</span> <span class="number">800</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"CM"</span>   <span class="special">,</span> <span class="number">900</span><span class="special">)</span>
        <span class="special">;</span>
    <span class="special">}</span>

<span class="special">}</span> <span class="identifier">hundreds</span><span class="special">;</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Here's a parser for roman tens (10..90):
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">tens_</span> <span class="special">:</span> <span class="identifier">symbols</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span> <span class="keyword">unsigned</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">tens_</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">add</span>
            <span class="special">(</span><span class="string">"X"</span>    <span class="special">,</span> <span class="number">10</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"XX"</span>   <span class="special">,</span> <span class="number">20</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"XXX"</span>  <span class="special">,</span> <span class="number">30</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"XL"</span>   <span class="special">,</span> <span class="number">40</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"L"</span>    <span class="special">,</span> <span class="number">50</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"LX"</span>   <span class="special">,</span> <span class="number">60</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"LXX"</span>  <span class="special">,</span> <span class="number">70</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"LXXX"</span> <span class="special">,</span> <span class="number">80</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"XC"</span>   <span class="special">,</span> <span class="number">90</span><span class="special">)</span>
        <span class="special">;</span>
    <span class="special">}</span>

<span class="special">}</span> <span class="identifier">tens</span><span class="special">;</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          and, finally, for ones (1..9):
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">ones_</span> <span class="special">:</span> <span class="identifier">symbols</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span> <span class="keyword">unsigned</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">ones_</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">add</span>
            <span class="special">(</span><span class="string">"I"</span>    <span class="special">,</span> <span class="number">1</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"II"</span>   <span class="special">,</span> <span class="number">2</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"III"</span>  <span class="special">,</span> <span class="number">3</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"IV"</span>   <span class="special">,</span> <span class="number">4</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"V"</span>    <span class="special">,</span> <span class="number">5</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"VI"</span>   <span class="special">,</span> <span class="number">6</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"VII"</span>  <span class="special">,</span> <span class="number">7</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"VIII"</span> <span class="special">,</span> <span class="number">8</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"IX"</span>   <span class="special">,</span> <span class="number">9</span><span class="special">)</span>
        <span class="special">;</span>
    <span class="special">}</span>

<span class="special">}</span> <span class="identifier">ones</span><span class="special">;</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Now we can use <tt class="computeroutput"><span class="identifier">hundreds</span></tt>,
          <tt class="computeroutput"><span class="identifier">tens</span></tt> and <tt class="computeroutput"><span class="identifier">ones</span></tt> anywhere in our parser expressions.
          They are all parsers.
        </p>
<a name="spirit.qi_and_karma.tutorials.roman_numerals.rules"></a><h5>
<a name="id468962"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.roman_numerals.rules">Rules</a>
        </h5>
<p>
          Up until now, we've been inlining our parser expressions, passing them
          directly to the <tt class="computeroutput"><span class="identifier">phrase_parse</span></tt>
          function. The expression evaluates into a temporary, unnamed parser which
          is passed into the <tt class="computeroutput"><span class="identifier">phrase_parse</span></tt>
          function, used, and then destroyed. This is fine for small parsers. When
          the expressions get complicated, you'd want to break the expressions into
          smaller easier to understand pieces, name them, and refer to them from
          other parser expressions by name.
        </p>
<p>
          A parser expression can be assigned to, what is called, a "rule".
          There are various ways to declare rules. The simplest form is:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">&gt;</span> <span class="identifier">r</span><span class="special">;</span>
</pre>
<p>
          At the very least, the rule needs to know the iterator type it will be
          working on. This rule cannot be used with <tt class="computeroutput"><span class="identifier">phrase_parse</span></tt>.
          It can only be used with the <tt class="computeroutput"><span class="identifier">parse</span></tt>
          function -- a version that does not do white space skipping (does not have
          the skipper argument). If you want to have it skip white spaces, you need
          to pass in the type skip parser, as in the next form:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">Skipper</span><span class="special">&gt;</span> <span class="identifier">r</span><span class="special">;</span>
</pre>
<p>
          Example:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">,</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">r</span><span class="special">;</span>
</pre>
<p>
          This type of rule can be used for both <tt class="computeroutput"><span class="identifier">phrase_parse</span></tt>
          and <tt class="computeroutput"><span class="identifier">parse</span></tt>.
        </p>
<p>
          For our next example, there's one more rule form you should know about:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">Signature</span><span class="special">&gt;</span> <span class="identifier">r</span><span class="special">;</span>
</pre>
<p>
          or
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">Signature</span><span class="special">,</span> <span class="identifier">Skipper</span><span class="special">&gt;</span> <span class="identifier">r</span><span class="special">;</span>
</pre>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
            All rule template arguments after Iterator can be supplied in any order.
          </p></td></tr>
</table></div>
<p>
          The Signature specifies the attributes of the rule. You've seen that our
          parsers can have an attribute. Recall that the <tt class="computeroutput"><span class="identifier">double_</span></tt>
          parser has an attribute of <tt class="computeroutput"><span class="keyword">double</span></tt>.
          To be precise, these are <span class="emphasis"><em>synthesized</em></span> attributes. The
          parser "synthesizes" the attribute value. Think of them as function
          return values.
        </p>
<p>
          There's another type of attribute called "inherited" attribute.
          We won't need them for now, but it's good that you be aware of such attributes.
          You can think of them as function arguments. And, rightly so, the rule
          signature is a function signature of the form:
        </p>
<pre class="programlisting"><span class="identifier">result</span><span class="special">(</span><span class="identifier">argN</span><span class="special">,</span> <span class="identifier">argN</span><span class="special">,...,</span> <span class="identifier">argN</span><span class="special">)</span>
</pre>
<p>
          After having declared a rule, you can now assign any parser expression
          to it. Example:
        </p>
<pre class="programlisting"><span class="identifier">r</span> <span class="special">=</span> <span class="identifier">double_</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="char">','</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">);</span>
</pre>
<a name="spirit.qi_and_karma.tutorials.roman_numerals.grammars"></a><h5>
<a name="id469547"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.roman_numerals.grammars">Grammars</a>
        </h5>
<p>
          A grammar encapsulates one or more rules. It has the same template parameters
          as the rule. You declare a grammar by:
        </p>
<div class="orderedlist"><ol type="1">
<li>
            deriving a struct (or class) from the <tt class="computeroutput"><span class="identifier">grammar</span></tt>
            class template
          </li>
<li>
            declare one or more rules as member variables
          </li>
<li>
            initialize the base grammar class by giving it the start rule (its the
            first rule that gets called when the grammar starts parsing)
          </li>
<li>
            initialize your rules in your constructor
          </li>
</ol></div>
<p>
          The roman numeral grammar is a very nice and simple example of a grammar:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">roman</span> <span class="special">:</span> <span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="keyword">unsigned</span><span class="special">()&gt;</span>
<span class="special">{</span>
    <span class="identifier">roman</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">roman</span><span class="special">::</span><span class="identifier">base_type</span><span class="special">(</span><span class="identifier">start</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">start</span> <span class="special">=</span> <span class="identifier">eps</span>             <span class="special">[</span><span class="identifier">_val</span> <span class="special">=</span> <span class="number">0</span><span class="special">]</span> <span class="special">&gt;&gt;</span>
            <span class="special">(</span>
                <span class="special">+</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'M'</span><span class="special">)</span>     <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="number">1000</span><span class="special">]</span>
                <span class="special">||</span>  <span class="identifier">hundreds</span>    <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]</span>
                <span class="special">||</span>  <span class="identifier">tens</span>        <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]</span>
                <span class="special">||</span>  <span class="identifier">ones</span>        <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]</span>
            <span class="special">)</span>
        <span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="keyword">unsigned</span><span class="special">()&gt;</span> <span class="identifier">start</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Things to take notice of:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            The grammar and start rule signature is <tt class="computeroutput"><span class="keyword">unsigned</span><span class="special">()</span></tt>. It has a synthesized attribute (return
            value) of type <tt class="computeroutput"><span class="keyword">unsigned</span></tt>
            with no inherited attributes (arguments).
          </li>
<li>
            We did not specify a skip-parser. We don't want to skip in between the
            numerals.
          </li>
<li>
<tt class="computeroutput"><span class="identifier">roman</span><span class="special">::</span><span class="identifier">base_type</span></tt> is a typedef for <tt class="computeroutput"><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span>
            <span class="keyword">unsigned</span><span class="special">()&gt;</span></tt>.
            If <tt class="computeroutput"><span class="identifier">roman</span></tt> was not a template,
            you can simply write: base_type(start)
          </li>
<li>
            But it's best to make your grammar templates, so that they can be reused
            for different iterator types.
          </li>
<li>
<tt class="computeroutput"><span class="identifier">_val</span></tt> is another <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a> placeholder representing
            the rule's synthesized attribute.
          </li>
<li>
<tt class="computeroutput"><span class="identifier">eps</span></tt> is a special spirit
            parser that consumes no input but is always successful. We use it to
            initialize <tt class="computeroutput"><span class="identifier">_val</span></tt>, the
            rule's synthesized attribute, to zero before anything else. The actual
            parser starts at <tt class="computeroutput"><span class="special">+</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'M'</span><span class="special">)</span></tt>,
            parsing roman thousands. Using <tt class="computeroutput"><span class="identifier">eps</span></tt>
            this way is good for doing pre and post initializations.
          </li>
<li>
            The expression <tt class="computeroutput"><span class="identifier">a</span> <span class="special">||</span>
            <span class="identifier">b</span></tt> reads: match a or b and in
            sequence. That is, if both <tt class="computeroutput"><span class="identifier">a</span></tt>
            and <tt class="computeroutput"><span class="identifier">b</span></tt> match, it must
            be in sequence; this is equivalent to <tt class="computeroutput"><span class="identifier">a</span>
            <span class="special">&gt;&gt;</span> <span class="special">!</span><span class="identifier">b</span> <span class="special">|</span> <span class="identifier">b</span></tt>, but more efficient.
          </li>
</ul></div>
<a name="spirit.qi_and_karma.tutorials.roman_numerals.let_s_parse_"></a><h5>
<a name="id470410"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.roman_numerals.let_s_parse_">Let's
          Parse!</a>
        </h5>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">parse</span><span class="special">(</span><span class="identifier">iter</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">roman_parser</span><span class="special">,</span> <span class="identifier">result</span><span class="special">);</span>

<span class="keyword">if</span> <span class="special">(</span><span class="identifier">r</span> <span class="special">&amp;&amp;</span> <span class="identifier">iter</span> <span class="special">==</span> <span class="identifier">end</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"-------------------------\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Parsing succeeded\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"result = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"-------------------------\n"</span><span class="special">;</span>
<span class="special">}</span>
<span class="keyword">else</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">rest</span><span class="special">(</span><span class="identifier">iter</span><span class="special">,</span> <span class="identifier">end</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"-------------------------\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Parsing failed\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"stopped at: \": "</span> <span class="special">&lt;&lt;</span> <span class="identifier">rest</span> <span class="special">&lt;&lt;</span> <span class="string">"\"\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"-------------------------\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          <tt class="computeroutput"><span class="identifier">roman_parser</span></tt> is an object
          of type <tt class="computeroutput"><span class="identifier">roman</span></tt> -our roman
          numeral parser. This time around, we are using the no-skipping version
          of the parse functions. We do not want to skip any spaces! We are also
          passing in an attribute, <tt class="computeroutput"><span class="keyword">unsigned</span>
          <span class="identifier">result</span></tt>, which will receive the
          parsed value.
        </p>
<p>
          The full cpp file for this example can be found here: <a href="../../../example/qi/roman.cpp" target="_top">../../example/qi/roman.cpp</a>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.employee___parsing_into_structs"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs" title="Employee
        - Parsing into structs">Employee
        - Parsing into structs</a></h4></div></div></div>
<p>
          It's a common question in the <a href="http://www.nabble.com/The-Spirit-Parser-Library-f3430.html" target="_top">Spirit
          General List</a>: how do I parse and place the results into a C++ struct?
          Of course, at this point, you already know various ways to do it, using
          semantic actions. There are many ways to skin a cat. Spirit2, being fully
          attributed, makes it even easier. The next example demonstrates some features
          of Spirit2 that makes this easy. In the process, you'll learn about:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            More about attributes
          </li>
<li>
            Auto rules
          </li>
<li>
            Some more built-in parsers
          </li>
<li>
            Directives
          </li>
</ul></div>
<p>
          First, let's create a struct representing an employee:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">employee</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">age</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">surname</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">forename</span><span class="special">;</span>
    <span class="keyword">double</span> <span class="identifier">salary</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Then, we need to tell <a href="http://spirit.sourceforge.net/dl_more/fusion_v2/libs/fusion/doc/html/index.html" target="_top">Fusion</a>
          about our employee struct to make it a first- class fusion citizen. If
          you don't know fusion yet, it is a <a href="http://www.boost.org/" target="_top">Boost</a>
          library for working with heterogenous collections of data, commonly referred
          to as tuples. Spirit uses fusion extensively as part of its infrastructure.
        </p>
<p>
          In fusion's view, a struct is just a form of a tuple. You can adapt any
          struct to be a fully conforming fusion tuple:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="identifier">BOOST_FUSION_ADAPT_STRUCT</span><span class="special">(</span>
    <span class="identifier">employee</span><span class="special">,</span>
    <span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">age</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">surname</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">forename</span><span class="special">)</span>
    <span class="special">(</span><span class="keyword">double</span><span class="special">,</span> <span class="identifier">salary</span><span class="special">)</span>
<span class="special">)</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Now we'll write a parser for our employee. Inputs will be of the form:
        </p>
<pre class="programlisting"><span class="identifier">employee</span><span class="special">{</span> <span class="identifier">age</span><span class="special">,</span> <span class="string">"surname"</span><span class="special">,</span> <span class="string">"forename"</span><span class="special">,</span> <span class="identifier">salary</span> <span class="special">}</span>
</pre>
<p>
          Here goes:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">employee_parser</span> <span class="special">:</span> <span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">employee</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">employee_parser</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">employee_parser</span><span class="special">::</span><span class="identifier">base_type</span><span class="special">(</span><span class="identifier">start</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">quoted_string</span> <span class="special">%=</span> <span class="identifier">lexeme</span><span class="special">[</span><span class="char">'"'</span> <span class="special">&gt;&gt;</span> <span class="special">+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'"'</span><span class="special">];</span>

        <span class="identifier">start</span> <span class="special">%=</span>
            <span class="identifier">lit</span><span class="special">(</span><span class="string">"employee"</span><span class="special">)</span>
            <span class="special">&gt;&gt;</span> <span class="char">'{'</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">int_</span> <span class="special">&gt;&gt;</span> <span class="char">','</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">quoted_string</span> <span class="special">&gt;&gt;</span> <span class="char">','</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">quoted_string</span> <span class="special">&gt;&gt;</span> <span class="char">','</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">double_</span>
            <span class="special">&gt;&gt;</span>  <span class="char">'}'</span>
            <span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">quoted_string</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">employee</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">start</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          The full cpp file for this example can be found here: <a href="../../../example/qi/employee.cpp" target="_top">../../example/qi/employee.cpp</a>
        </p>
<p>
          Let's walk through this one step at a time (not necessarily from top to
          bottom).
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">employee_parser</span> <span class="special">:</span> <span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">employee</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span>
</pre>
<p>
          <tt class="computeroutput"><span class="identifier">employee_parser</span></tt> is a grammar.
          Like before, we make it a template so that we can reuse it for different
          iterator types. The grammar's signature is:
        </p>
<pre class="programlisting"><span class="identifier">employee</span><span class="special">()</span>
</pre>
<p>
          meaning, the parser generates employee structs. <tt class="computeroutput"><span class="identifier">employee_parser</span></tt>
          skips white spaces using <tt class="computeroutput"><span class="identifier">space_type</span></tt>
          as its skip parser.
        </p>
<pre class="programlisting"><span class="identifier">employee_parser</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">employee_parser</span><span class="special">::</span><span class="identifier">base_type</span><span class="special">(</span><span class="identifier">start</span><span class="special">)</span>
</pre>
<p>
          Initializes the base class.
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">quoted_string</span><span class="special">;</span>
<span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">employee</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">start</span><span class="special">;</span>
</pre>
<p>
          Declares two rules: <tt class="computeroutput"><span class="identifier">quoted_string</span></tt>
          and <tt class="computeroutput"><span class="identifier">start</span></tt>. <tt class="computeroutput"><span class="identifier">start</span></tt> has the same template parameters
          as the grammar itself. <tt class="computeroutput"><span class="identifier">quoted_string</span></tt>
          has a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt> attribute.
        </p>
<a name="spirit.qi_and_karma.tutorials.employee___parsing_into_structs.lexeme"></a><h5>
<a name="id472484"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs.lexeme">Lexeme</a>
        </h5>
<pre class="programlisting"><span class="identifier">lexeme</span><span class="special">[</span><span class="char">'"'</span> <span class="special">&gt;&gt;</span> <span class="special">+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'"'</span><span class="special">];</span>
</pre>
<p>
          <tt class="computeroutput"><span class="identifier">lexeme</span></tt> inhibits space skipping
          from the open brace to the closing brace. The expression parses quoted
          strings.
        </p>
<pre class="programlisting"><span class="special">+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span>
</pre>
<p>
          parses one or more chars, except the double quote. It stops when it sees
          a double quote.
        </p>
<a name="spirit.qi_and_karma.tutorials.employee___parsing_into_structs.difference"></a><h5>
<a name="id472645"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs.difference">Difference</a>
        </h5>
<p>
          The expression:
        </p>
<pre class="programlisting"><span class="identifier">a</span> <span class="special">-</span> <span class="identifier">b</span>
</pre>
<p>
          parses <tt class="computeroutput"><span class="identifier">a</span></tt> but not <tt class="computeroutput"><span class="identifier">b</span></tt>. Its attribute is just <tt class="computeroutput"><span class="identifier">A</span></tt>, the attribute of <tt class="computeroutput"><span class="identifier">a</span></tt>.
          <tt class="computeroutput"><span class="identifier">b</span></tt>'s attribute is ignored.
          Hence, the attribute of:
        </p>
<pre class="programlisting"><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span>
</pre>
<p>
          is just <tt class="computeroutput"><span class="keyword">char</span></tt>.
        </p>
<a name="spirit.qi_and_karma.tutorials.employee___parsing_into_structs.plus"></a><h5>
<a name="id472806"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs.plus">Plus</a>
        </h5>
<pre class="programlisting"><span class="special">+</span><span class="identifier">a</span>
</pre>
<p>
          is the close kin of the kleene star we got so used to in our tutorial.
          Like it's kin, the kleene star, its attribute is a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">&gt;</span></tt> where <tt class="computeroutput"><span class="identifier">A</span></tt>
          is the attribute of <tt class="computeroutput"><span class="identifier">a</span></tt>.
          So, putting all these together, the attribute of
        </p>
<pre class="programlisting"><span class="special">+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span>
</pre>
<p>
          is then:
        </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span>
</pre>
<a name="spirit.qi_and_karma.tutorials.employee___parsing_into_structs.sequence_attribute"></a><h5>
<a name="id472994"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs.sequence_attribute">Sequence
          Attribute</a>
        </h5>
<p>
          Now what's the attribute of
        </p>
<pre class="programlisting"><span class="char">'"'</span> <span class="special">&gt;&gt;</span> <span class="special">+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'"'</span>
</pre>
<p>
          ?
        </p>
<p>
          Well, typically, the attribute of:
        </p>
<pre class="programlisting"><span class="identifier">a</span> <span class="special">&gt;&gt;</span> <span class="identifier">b</span> <span class="special">&gt;&gt;</span> <span class="identifier">c</span>
</pre>
<p>
          is:
        </p>
<pre class="programlisting"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">,</span> <span class="identifier">C</span><span class="special">&gt;</span>
</pre>
<p>
          where <tt class="computeroutput"><span class="identifier">A</span></tt> is the attribute
          of <tt class="computeroutput"><span class="identifier">a</span></tt>, <tt class="computeroutput"><span class="identifier">B</span></tt>
          is the attribute of <tt class="computeroutput"><span class="identifier">b</span></tt> and
          <tt class="computeroutput"><span class="identifier">C</span></tt> is the attribute of
          <tt class="computeroutput"><span class="identifier">c</span></tt>. What is <tt class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">vector</span></tt>? - a tuple.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
            If you don't know what I am talking about, see: <a href="http://tinyurl.com/6xun4j" target="_top">Fusion
            Vector</a>. It might be a good idea to have a look into <a href="http://spirit.sourceforge.net/dl_more/fusion_v2/libs/fusion/doc/html/index.html" target="_top">Fusion</a>
            at this point. You'll definitely see more of it in the coming pages.
          </p></td></tr>
</table></div>
<a name="spirit.qi_and_karma.tutorials.employee___parsing_into_structs.attribute_collapsing"></a><h5>
<a name="id473317"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs.attribute_collapsing">Attribute
          Collapsing</a>
        </h5>
<p>
          Some parsers, especially those very little literal parsers you see, like
          <tt class="computeroutput"><span class="char">'"'</span></tt>, do not have attributes.
        </p>
<p>
          Nodes without attributes are disregarded. In a sequence, like above, all
          nodes with no attributes are filtered out of the <tt class="computeroutput"><span class="identifier">fusion</span><span class="special">:</span><span class="identifier">vector</span></tt>.
          So, since <tt class="computeroutput"><span class="char">'"'</span></tt> has no attribute,
          and <tt class="computeroutput"><span class="special">+(</span><span class="identifier">char_</span>
          <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span></tt> has a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span></tt> attribute, the whole expression's attribute
          should have been:
        </p>
<pre class="programlisting"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span>
</pre>
<p>
          But wait, there's one more collapsing rule: If after the attribute is a
          single element <tt class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">vector</span></tt>, The element is stripped naked
          from its container. So, to make a long story short, the attribute of the
          expression:
        </p>
<pre class="programlisting"><span class="char">'"'</span> <span class="special">&gt;&gt;</span> <span class="special">+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'"'</span>
</pre>
<p>
          is:
        </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span>
</pre>
<a name="spirit.qi_and_karma.tutorials.employee___parsing_into_structs.auto_rules"></a><h5>
<a name="id473668"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs.auto_rules">Auto
          Rules</a>
        </h5>
<p>
          It is typical to see rules like:
        </p>
<pre class="programlisting"><span class="identifier">r</span> <span class="special">=</span> <span class="identifier">p</span><span class="special">[</span><span class="identifier">_val</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">];</span>
</pre>
<p>
          If you have a rule definition like above where the attribute of the RHS
          (right hand side) of the rule is compatibe with the attribute of the LHS
          (left hand side), then you can rewrite it as:
        </p>
<pre class="programlisting"><span class="identifier">r</span> <span class="special">%=</span> <span class="identifier">p</span><span class="special">;</span>
</pre>
<p>
          The attribute of <tt class="computeroutput"><span class="identifier">p</span></tt> automatically
          uses the attribute of <tt class="computeroutput"><span class="identifier">r</span></tt>.
        </p>
<p>
          So, going back to our <tt class="computeroutput"><span class="identifier">quoted_string</span></tt>
          rule:
        </p>
<pre class="programlisting"><span class="identifier">quoted_string</span> <span class="special">%=</span> <span class="identifier">lexeme</span><span class="special">[</span><span class="char">'"'</span> <span class="special">&gt;&gt;</span> <span class="special">+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'"'</span><span class="special">];</span>
</pre>
<p>
          is a simplified version of:
        </p>
<pre class="programlisting"><span class="identifier">quoted_string</span> <span class="special">=</span> <span class="identifier">lexeme</span><span class="special">[</span><span class="char">'"'</span> <span class="special">&gt;&gt;</span> <span class="special">+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'"'</span><span class="special">][</span><span class="identifier">val_</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">];</span>
</pre>
<p>
          The attribute of the <tt class="computeroutput"><span class="identifier">quoted_string</span></tt>
          rule: <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt> <span class="bold"><b>is compatible</b></span>
          with the attribute of the RHS: <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span></tt>. The RHS extracts the parsed attribute
          directly into the rule's attribute, in-situ.
        </p>
<a name="spirit.qi_and_karma.tutorials.employee___parsing_into_structs.finally"></a><h5>
<a name="id474119"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.employee___parsing_into_structs.finally">Finally</a>
        </h5>
<p>
          We're down to one rule, the start rule:
        </p>
<pre class="programlisting"><span class="identifier">start</span> <span class="special">%=</span>
    <span class="identifier">lit</span><span class="special">(</span><span class="string">"employee"</span><span class="special">)</span>
    <span class="special">&gt;&gt;</span> <span class="char">'{'</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">int_</span> <span class="special">&gt;&gt;</span> <span class="char">','</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">quoted_string</span> <span class="special">&gt;&gt;</span> <span class="char">','</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">quoted_string</span> <span class="special">&gt;&gt;</span> <span class="char">','</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">double_</span>
    <span class="special">&gt;&gt;</span>  <span class="char">'}'</span>
    <span class="special">;</span>
</pre>
<p>
          Applying our collapsing rules above, the RHS has an attribute of:
        </p>
<pre class="programlisting"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">double</span><span class="special">&gt;</span>
</pre>
<p>
          These nodes do not have an attribute:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><tt class="computeroutput"><span class="identifier">lit</span><span class="special">(</span><span class="string">"employee"</span><span class="special">)</span></tt></li>
<li><tt class="computeroutput"><span class="char">'{'</span></tt></li>
<li><tt class="computeroutput"><span class="char">'}'</span></tt></li>
</ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
            In case you are wondering, <tt class="computeroutput"><span class="identifier">lit</span><span class="special">(</span><span class="string">"employee"</span><span class="special">)</span></tt> is the same as "employee".
            We had to wrap it inside <tt class="computeroutput"><span class="identifier">lit</span></tt>
            because immediately after it is <tt class="computeroutput"><span class="special">&gt;&gt;</span>
            <span class="char">'{'</span></tt>. You can't right-shift a <tt class="computeroutput"><span class="keyword">char</span><span class="special">[]</span></tt>
            and a <tt class="computeroutput"><span class="keyword">char</span></tt> - you know, C++
            syntax rules.
          </p></td></tr>
</table></div>
<p>
          Recall that the attribute of <tt class="computeroutput"><span class="identifier">start</span></tt>
          is the <tt class="computeroutput"><span class="identifier">employee</span></tt> struct:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">employee</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">age</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">surname</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">forename</span><span class="special">;</span>
    <span class="keyword">double</span> <span class="identifier">salary</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Now everything is clear, right? The <tt class="computeroutput"><span class="keyword">struct</span>
          <span class="identifier">employee</span></tt> <span class="bold"><b>IS</b></span>
          compatible with <tt class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">double</span><span class="special">&gt;</span></tt>. So, the RHS of <tt class="computeroutput"><span class="identifier">start</span></tt>
          uses start's attribute (a <tt class="computeroutput"><span class="keyword">struct</span>
          <span class="identifier">employee</span></tt>) in-situ when it does
          its work.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_" title="Mini
        XML - ASTs!">Mini
        XML - ASTs!</a></h4></div></div></div>
<p>
          Stop and think about it... We've come very close to generating an AST in
          our last example. We parsed a single structure and generated an in-memory
          representation of it in the form of a struct: the <tt class="computeroutput"><span class="keyword">struct</span>
          <span class="identifier">employee</span></tt>. If we changed the implementation
          to parse one or more employees, the result would be a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;</span></tt>. We can go on and add more hierarchy:
          teams, departments, corporations. Then we'll have an AST representation
          of it all.
        </p>
<p>
          In this example (actually two examples), we'll now explore parsers how
          to create ASTs. We will parse a minimalistic XML like language and compile
          the results into our data structures in the form of a tree.
        </p>
<p>
          Along the way, we'll see new features:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            Inherited attributes
          </li>
<li>
            Variant attributes
          </li>
<li>
            Local Variables
          </li>
<li>
            Not Predicate
          </li>
<li>
            Lazy Lit
          </li>
</ul></div>
<p>
          The full cpp files for these examples can be found here: <a href="../../../example/qi/mini_xml1.cpp" target="_top">../../example/qi/mini_xml1.cpp</a>
          and here: <a href="../../../example/qi/mini_xml2.cpp" target="_top">../../example/qi/mini_xml2.cpp</a>
        </p>
<p>
          There are a couple of sample toy-xml files in: <a href="../../../example/qi/mini_xml_samples" target="_top">../../example/qi/mini_xml_samples</a>
          for testing purposes. "4.toyxml" has an error in it.
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.first_cut"></a><h5>
<a name="id475029"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.first_cut">First
          Cut</a>
        </h5>
<p>
          Without further delay, here's the first version of the XML grammar:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mini_xml_grammar</span> <span class="special">:</span> <span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">mini_xml_grammar</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">mini_xml_grammar</span><span class="special">::</span><span class="identifier">base_type</span><span class="special">(</span><span class="identifier">xml</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">text</span> <span class="special">=</span> <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&lt;'</span><span class="special">)</span>        <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]];</span>
        <span class="identifier">node</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">xml</span> <span class="special">|</span> <span class="identifier">text</span><span class="special">)</span>                 <span class="special">[</span><span class="identifier">_val</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">];</span>

        <span class="identifier">start_tag</span> <span class="special">=</span>
                <span class="char">'&lt;'</span>
            <span class="special">&gt;&gt;</span>  <span class="special">!</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&gt;'</span><span class="special">)</span>       <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]]</span>
            <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">end_tag</span> <span class="special">=</span>
                <span class="string">"&lt;/"</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">lit</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
            <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">xml</span> <span class="special">=</span>
                <span class="identifier">start_tag</span>                   <span class="special">[</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
            <span class="special">&gt;&gt;</span>  <span class="special">*</span><span class="identifier">node</span>                       <span class="special">[</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">),</span> <span class="identifier">_1</span><span class="special">)]</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">))</span>
        <span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">xml</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml_node</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">node</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">text</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">start_tag</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">end_tag</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Going bottom up, let's examine the <tt class="computeroutput"><span class="identifier">text</span></tt>
          rule:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">text</span><span class="special">;</span>
</pre>
<p>
          and its definition:
        </p>
<pre class="programlisting"><span class="identifier">text</span> <span class="special">=</span> <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&lt;'</span><span class="special">)</span>        <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]];</span>
</pre>
<p>
          The semantic action collects the chars and appends them (via +=) to the
          <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt> attribute of the rule (represented
          by the placeholder <tt class="computeroutput"><span class="identifier">_val</span></tt>).
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.alternates"></a><h5>
<a name="id476318"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.alternates">Alternates</a>
        </h5>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml_node</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">node</span><span class="special">;</span>
</pre>
<p>
          and its definition:
        </p>
<pre class="programlisting"><span class="identifier">node</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">xml</span> <span class="special">|</span> <span class="identifier">text</span><span class="special">)</span>                 <span class="special">[</span><span class="identifier">_val</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">];</span>
</pre>
<p>
          We'll see what a <tt class="computeroutput"><span class="identifier">mini_xml_node</span></tt>
          structure later. Looking at the rule definition, we see some alternation
          goiing on here. An xml <tt class="computeroutput"><span class="identifier">node</span></tt>
          is either an <tt class="computeroutput"><span class="identifier">xml</span></tt> OR <tt class="computeroutput"><span class="identifier">text</span></tt>. Hmmm... hold on to that thought...
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">start_tag</span><span class="special">;</span>
</pre>
<p>
          Again, with an attribute of <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt>.
          Then, it's definition:
        </p>
<pre class="programlisting"><span class="identifier">start_tag</span> <span class="special">=</span>
        <span class="char">'&lt;'</span>
    <span class="special">&gt;&gt;</span>  <span class="special">!</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&gt;'</span><span class="special">)</span>       <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]]</span>
    <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
<span class="special">;</span>
</pre>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.not_predicate"></a><h5>
<a name="id476781"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.not_predicate">Not
          Predicate</a>
        </h5>
<p>
          <tt class="computeroutput"><span class="identifier">start_tag</span></tt> is similar to
          the <tt class="computeroutput"><span class="identifier">text</span></tt> rule apart from
          the added <tt class="computeroutput"><span class="char">'&lt;'</span></tt> and <tt class="computeroutput"><span class="char">'&gt;'</span></tt>. But wait, to make sure that the <tt class="computeroutput"><span class="identifier">start_tag</span></tt> does not parse <tt class="computeroutput"><span class="identifier">end_tag</span></tt>s too, we add: <tt class="computeroutput"><span class="special">!</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span></tt>. This
          is a "Not Predicate":
        </p>
<pre class="programlisting"><span class="special">!</span><span class="identifier">p</span>
</pre>
<p>
          It will try the parser, <tt class="computeroutput"><span class="identifier">p</span></tt>.
          If it is successful, fail, otherwise, pass. In other words, it negates
          the result of <tt class="computeroutput"><span class="identifier">p</span></tt>. Like the
          <tt class="computeroutput"><span class="identifier">eps</span></tt>, it does not consume
          any input though. It will always rewind the iterator position to where
          it was upon entry. So, the expression:
        </p>
<pre class="programlisting"><span class="special">!</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span>
</pre>
<p>
          basically says: we should not have a <tt class="computeroutput"><span class="char">'/'</span></tt>
          at this point.
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.inherited_attribute"></a><h5>
<a name="id477026"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.inherited_attribute">Inherited
          Attribute</a>
        </h5>
<p>
          The <tt class="computeroutput"><span class="identifier">end_tag</span></tt>:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">end_tag</span><span class="special">;</span>
</pre>
<p>
          Ohh! Now we see an inherited attribute there: <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt>.
          The <tt class="computeroutput"><span class="identifier">end_tag</span></tt> does not have
          a synthesized attribute. Let's see its definition:
        </p>
<pre class="programlisting"><span class="identifier">end_tag</span> <span class="special">=</span>
        <span class="string">"&lt;/"</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">lit</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
    <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
<span class="special">;</span>
</pre>
<p>
          <tt class="computeroutput"><span class="identifier">_r1</span></tt> is yet another <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a> placeholder for
          the 1st inherited attribute (we have only one, use <tt class="computeroutput"><span class="identifier">_r2</span></tt>,
          <tt class="computeroutput"><span class="identifier">_r3</span></tt>, etc. if you have more).
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.a_lazy_lit"></a><h5>
<a name="id477308"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.a_lazy_lit">A
          Lazy Lit</a>
        </h5>
<p>
          Check out how we used <tt class="computeroutput"><span class="identifier">lit</span></tt>
          here, this time, not with a literal string, but with the value of the 1st
          inherited attribute, which is specified as <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt>
          in our rule declaration.
        </p>
<p>
          Finally, our <tt class="computeroutput"><span class="identifier">xml</span></tt> rule:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">xml</span><span class="special">;</span>
</pre>
<p>
          <tt class="computeroutput"><span class="identifier">mini_xml</span></tt> is our attribute
          here. We'll see later what it is. Let's see its definition:
        </p>
<pre class="programlisting"><span class="identifier">xml</span> <span class="special">=</span>
        <span class="identifier">start_tag</span>                   <span class="special">[</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
    <span class="special">&gt;&gt;</span>  <span class="special">*</span><span class="identifier">node</span>                       <span class="special">[</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">),</span> <span class="identifier">_1</span><span class="special">)]</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">))</span>
<span class="special">;</span>
</pre>
<p>
          Those who know <a href="http://spirit.sourceforge.net/dl_more/fusion_v2/libs/fusion/doc/html/index.html" target="_top">Fusion</a>
          now will notice <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></tt> and
          <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span></tt>. This
          gives us a hint that <tt class="computeroutput"><span class="identifier">mini_xml</span></tt>
          is a sort of a tuple - a fusion sequence. <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;</span></tt> here is a lazy version of the tuple
          accessors, provided by <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a>.
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.how_it_all_works"></a><h5>
<a name="id477789"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.how_it_all_works">How
          it all works</a>
        </h5>
<p>
          So, what's happening?
        </p>
<div class="orderedlist"><ol type="1">
<li>
            Upon parsing <tt class="computeroutput"><span class="identifier">start_tag</span></tt>,
            the parsed start-tag string is placed in <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span></tt>.
          </li>
<li>
            Then we parse zero or more <tt class="computeroutput"><span class="identifier">node</span></tt>s.
            At each step, we <tt class="computeroutput"><span class="identifier">push_back</span></tt>
            the result into <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span></tt>.
          </li>
<li>
            Finally, we parse the <tt class="computeroutput"><span class="identifier">end_tag</span></tt>
            giving it an inherited attribute: <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span></tt>.
            This is the string we obtained from the <tt class="computeroutput"><span class="identifier">start_tag</span></tt>.
            Investigate <tt class="computeroutput"><span class="identifier">end_tag</span></tt> above.
            It will fail to parse if it gets something different from what we got
            from the <tt class="computeroutput"><span class="identifier">start_tag</span></tt>. This
            ensures that our tags are balanced.
          </li>
</ol></div>
<p>
          To give the last item some more light, what happens is this:
        </p>
<pre class="programlisting"><span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">))</span>
</pre>
<p>
          calls:
        </p>
<pre class="programlisting"><span class="identifier">end_tag</span> <span class="special">=</span>
        <span class="string">"&lt;/"</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">lit</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
    <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
<span class="special">;</span>
</pre>
<p>
          passing in <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span></tt>, the string from start tag. This is referred
          to in the <tt class="computeroutput"><span class="identifier">end_tag</span></tt> body
          as <tt class="computeroutput"><span class="identifier">_r1</span></tt>.
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.the_structures"></a><h5>
<a name="id478235"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.the_structures">The
          Structures</a>
        </h5>
<p>
          Let's see our structures. It will definitely be hierarchical: xml is hierarchical.
          It will also be recursive: xml is recursive.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">mini_xml</span><span class="special">;</span>

<span class="keyword">typedef</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">mini_xml</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span>
    <span class="special">&gt;</span>
<span class="identifier">mini_xml_node</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">mini_xml</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">name</span><span class="special">;</span>                           <span class="comment">// tag name
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">mini_xml_node</span><span class="special">&gt;</span> <span class="identifier">children</span><span class="special">;</span>        <span class="comment">// children
</span><span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.of_alternates_and_variants"></a><h5>
<a name="id478508"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.of_alternates_and_variants">Of
          Alternates and Variants</a>
        </h5>
<p>
          So that's how a <tt class="computeroutput"><span class="identifier">mini_xml_node</span></tt>
          looks like. We had a hint that it is either a <tt class="computeroutput"><span class="identifier">string</span></tt>
          or a <tt class="computeroutput"><span class="identifier">mini_xml</span></tt>. For this,
          we use <a href="http://www.boost.org/doc/html/variant.html" target="_top"><tt class="computeroutput"><span class="identifier">boost</span><span class="special">.</span><span class="identifier">variant</span><span class="special">&lt;&gt;</span></tt></a>.
          <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_wrapper</span></tt> wraps <tt class="computeroutput"><span class="identifier">mini_xml</span></tt>, making it a recursive data
          structure.
        </p>
<p>
          Yep, you got that right: the attribute of an alternate:
        </p>
<pre class="programlisting"><span class="identifier">a</span> <span class="special">|</span> <span class="identifier">b</span>
</pre>
<p>
          is a
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;</span>
</pre>
<p>
          where <tt class="computeroutput"><span class="identifier">A</span></tt> is the attribute
          of <tt class="computeroutput"><span class="identifier">a</span></tt> and <tt class="computeroutput"><span class="identifier">B</span></tt> is the attribute of <tt class="computeroutput"><span class="identifier">b</span></tt>.
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.adapting_structs_again"></a><h5>
<a name="id478778"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.adapting_structs_again">Adapting
          structs again</a>
        </h5>
<p>
          <tt class="computeroutput"><span class="identifier">mini_xml</span></tt> is no brainier.
          It is a plain ol' struct. But as we've seen in our employee example, we
          can adapt that to be a <a href="http://spirit.sourceforge.net/dl_more/fusion_v2/libs/fusion/doc/html/index.html" target="_top">Fusion</a>
          sequence:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="identifier">BOOST_FUSION_ADAPT_STRUCT</span><span class="special">(</span>
    <span class="identifier">mini_xml</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">name</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">mini_xml_node</span><span class="special">&gt;,</span> <span class="identifier">children</span><span class="special">)</span>
<span class="special">)</span>
</pre>
<p>
          </p>
<p>
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.one_more_take"></a><h5>
<a name="id478959"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.one_more_take">One
          More Take</a>
        </h5>
<p>
          Here's another version. The AST structure remains the same, but this time,
          you'll see that we make use of auto-rules making the grammar semantic-action-
          less. Here it is:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mini_xml_grammar</span>
  <span class="special">:</span> <span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">locals</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span> <span class="identifier">space_type</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">mini_xml_grammar</span><span class="special">()</span>
      <span class="special">:</span> <span class="identifier">mini_xml_grammar</span><span class="special">::</span><span class="identifier">base_type</span><span class="special">(</span><span class="identifier">xml</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">text</span> <span class="special">%=</span> <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&lt;'</span><span class="special">)];</span>
        <span class="identifier">node</span> <span class="special">%=</span> <span class="identifier">xml</span> <span class="special">|</span> <span class="identifier">text</span><span class="special">;</span>

        <span class="identifier">start_tag</span> <span class="special">%=</span>
                <span class="char">'&lt;'</span>
            <span class="special">&gt;&gt;</span>  <span class="special">!</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&gt;'</span><span class="special">)]</span>
            <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">end_tag</span> <span class="special">=</span>
                <span class="string">"&lt;/"</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">lit</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
            <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">xml</span> <span class="special">%=</span>
                <span class="identifier">start_tag</span><span class="special">[</span><span class="identifier">_a</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
            <span class="special">&gt;&gt;</span>  <span class="special">*</span><span class="identifier">node</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">_a</span><span class="special">)</span>
        <span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">locals</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">xml</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml_node</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">node</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">text</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">start_tag</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">end_tag</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          This one shouldn't be any more difficult to understand after going through
          the first xml parser example. The rules are almost the same, except that,
          we got rid of semantic actions and used auto-rules (see the employee example
          if you missed that). There are a couple of new stuff, though. It's all
          in the <tt class="computeroutput"><span class="identifier">xml</span></tt> rule:
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___asts_.local_variables"></a><h5>
<a name="id479925"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___asts_.local_variables">Local
          Variables</a>
        </h5>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">locals</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">xml</span><span class="special">;</span>
</pre>
<p>
          Wow, we have four template parameters now. What's that <tt class="computeroutput"><span class="identifier">locals</span></tt>
          guy doing there? Well, it declares that the rule <tt class="computeroutput"><span class="identifier">xml</span></tt>
          will have one local variable: a <tt class="computeroutput"><span class="identifier">string</span></tt>.
          Let's see how this is used in action:
        </p>
<pre class="programlisting"><span class="identifier">xml</span> <span class="special">%=</span>
        <span class="identifier">start_tag</span><span class="special">[</span><span class="identifier">_a</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
    <span class="special">&gt;&gt;</span>  <span class="special">*</span><span class="identifier">node</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">_a</span><span class="special">)</span>
<span class="special">;</span>
</pre>
<div class="orderedlist"><ol type="1">
<li>
            Upon parsing <tt class="computeroutput"><span class="identifier">start_tag</span></tt>,
            the parsed start-tag string is placed in the local variable specified
            by (yet another) <a href="../../../phoenix/doc/html/index.html" target="_top">Phoenix</a>
            placeholder: <tt class="computeroutput"><span class="identifier">_a</span></tt>. We have
            only one local variable. If we had more, these are designated by <tt class="computeroutput"><span class="identifier">_b</span></tt>..<tt class="computeroutput"><span class="identifier">_z</span></tt>.
          </li>
<li>
            Then we parse zero or more <tt class="computeroutput"><span class="identifier">node</span></tt>s.
          </li>
<li>
            Finally, we parse the <tt class="computeroutput"><span class="identifier">end_tag</span></tt>
            giving it an inherited attribute: <tt class="computeroutput"><span class="identifier">_a</span></tt>,
            our local variable.
          </li>
</ol></div>
<p>
          There are no actions involved in stuffing data into our <tt class="computeroutput"><span class="identifier">xml</span></tt>
          attribute. It's all taken cared of thatnks to the auto-rule.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="spirit.qi_and_karma.tutorials.mini_xml___error_handling"></a><a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___error_handling" title="Mini
        XML - Error Handling">Mini
        XML - Error Handling</a></h4></div></div></div>
<p>
          A parser will not be complete without error handling. Spirit2 provides
          some facilities to make it easy to adapt a grammar for error handling.
          We'll wrap up the Qi tutorial with another version of the mini xml parser,
          this time, with error handling.
        </p>
<p>
          <a href="../../../example/qi/mini_xml1.cpp" target="_top">../../example/qi/mini_xml1.cpp</a>
          and here: <a href="../../../example/qi/mini_xml2.cpp" target="_top">../../example/qi/mini_xml2.cpp</a>
        </p>
<p>
          Here's the grammar:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mini_xml_grammar</span>
  <span class="special">:</span> <span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">locals</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span> <span class="identifier">space_type</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">mini_xml_grammar</span><span class="special">()</span>
      <span class="special">:</span> <span class="identifier">mini_xml_grammar</span><span class="special">::</span><span class="identifier">base_type</span><span class="special">(</span><span class="identifier">xml</span><span class="special">,</span> <span class="string">"xml"</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">text</span> <span class="special">%=</span> <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&lt;'</span><span class="special">)];</span>
        <span class="identifier">node</span> <span class="special">%=</span> <span class="identifier">xml</span> <span class="special">|</span> <span class="identifier">text</span><span class="special">;</span>

        <span class="identifier">start_tag</span> <span class="special">%=</span>
                <span class="char">'&lt;'</span>
            <span class="special">&gt;&gt;</span>  <span class="special">!</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span>
            <span class="special">&gt;</span>   <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&gt;'</span><span class="special">)]</span>
            <span class="special">&gt;</span>   <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">end_tag</span> <span class="special">=</span>
                <span class="string">"&lt;/"</span>
            <span class="special">&gt;</span>   <span class="identifier">lit</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
            <span class="special">&gt;</span>   <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">xml</span> <span class="special">%=</span>
                <span class="identifier">start_tag</span><span class="special">[</span><span class="identifier">_a</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
            <span class="special">&gt;</span>   <span class="special">*</span><span class="identifier">node</span>
            <span class="special">&gt;</span>   <span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">_a</span><span class="special">)</span>
        <span class="special">;</span>

        <span class="identifier">xml</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"xml"</span><span class="special">);</span>
        <span class="identifier">node</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"node"</span><span class="special">);</span>
        <span class="identifier">text</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"text"</span><span class="special">);</span>
        <span class="identifier">start_tag</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"start_tag"</span><span class="special">);</span>
        <span class="identifier">end_tag</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"end_tag"</span><span class="special">);</span>

        <span class="identifier">on_error</span><span class="special">&lt;</span><span class="identifier">fail</span><span class="special">&gt;</span>
        <span class="special">(</span>
            <span class="identifier">xml</span>
          <span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span>
                <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"Error! Expecting "</span><span class="special">)</span>
                <span class="special">&lt;&lt;</span> <span class="identifier">_4</span>                               <span class="comment">// what failed?
</span>                <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">" here: \""</span><span class="special">)</span>
                <span class="special">&lt;&lt;</span> <span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">_3</span><span class="special">,</span> <span class="identifier">_2</span><span class="special">)</span>   <span class="comment">// iterators to error-pos, end
</span>                <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"\""</span><span class="special">)</span>
                <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span>
        <span class="special">);</span>
    <span class="special">}</span>

    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">locals</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">xml</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml_node</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">node</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">text</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">start_tag</span><span class="special">;</span>
    <span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">end_tag</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          What's new?
        </p>
<a name="spirit.qi_and_karma.tutorials.mini_xml___error_handling.readable_names"></a><h5>
<a name="id481710"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___error_handling.readable_names">Readable
          Names</a>
        </h5>
<p>
          First, when we call the base class, we give the grammar a name:
        </p>
<pre class="programlisting"><span class="special">:</span> <span class="identifier">mini_xml_grammar</span><span class="special">::</span><span class="identifier">base_type</span><span class="special">(</span><span class="identifier">xml</span><span class="special">,</span> <span class="string">"xml"</span><span class="special">)</span>
</pre>
<p>
          Then, we name all our rules:
        </p>
<pre class="programlisting"><span class="identifier">xml</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"xml"</span><span class="special">);</span>
<span class="identifier">node</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"node"</span><span class="special">);</span>
<span class="identifier">text</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"text"</span><span class="special">);</span>
<span class="identifier">start_tag</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"start_tag"</span><span class="special">);</span>
<span class="identifier">end_tag</span><span class="special">.</span><span class="identifier">name</span><span class="special">(</span><span class="string">"end_tag"</span><span class="special">);</span>
</pre>
<a name="spirit.qi_and_karma.tutorials.mini_xml___error_handling.on_error"></a><h5>
<a name="id481964"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___error_handling.on_error">On
          Error</a>
        </h5>
<p>
          <tt class="computeroutput"><span class="identifier">on_error</span></tt> declares our error
          handler:
        </p>
<pre class="programlisting"><span class="identifier">on_error</span><span class="special">&lt;</span><span class="identifier">Action</span><span class="special">&gt;(</span><span class="identifier">rule</span><span class="special">,</span> <span class="identifier">handler</span><span class="special">)</span>
</pre>
<p>
          This will specify what we will do when we get an error. We will print out
          an error message using phoenix:
        </p>
<pre class="programlisting"><span class="identifier">on_error</span><span class="special">&lt;</span><span class="identifier">fail</span><span class="special">&gt;</span>
<span class="special">(</span>
    <span class="identifier">xml</span>
  <span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span>
        <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"Error! Expecting "</span><span class="special">)</span>
        <span class="special">&lt;&lt;</span> <span class="identifier">_4</span>                               <span class="comment">// what failed?
</span>        <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">" here: \""</span><span class="special">)</span>
        <span class="special">&lt;&lt;</span> <span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">_3</span><span class="special">,</span> <span class="identifier">_2</span><span class="special">)</span>   <span class="comment">// iterators to error-pos, end
</span>        <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"\""</span><span class="special">)</span>
        <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span>
<span class="special">);</span>
</pre>
<p>
          we choose to <tt class="computeroutput"><span class="identifier">fail</span></tt> in our
          example for the <tt class="computeroutput"><span class="identifier">Action</span></tt>:
          Quit and fail. Return a no_match (false). It can be one of:
        </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  <tt class="computeroutput"><span class="identifier">Action</span></tt>
                </p>
                </th>
<th>
                <p>
                  Description
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  fail
                </p>
                </td>
<td>
                <p>
                  Quit and fail. Return a no_match.
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  retry
                </p>
                </td>
<td>
                <p>
                  Attempt error recovery, possibly moving the iterator position.
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  accept
                </p>
                </td>
<td>
                <p>
                  Force success, moving the iterator position appropriately.
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  rethrow
                </p>
                </td>
<td>
                <p>
                  Rethrows the error.
                </p>
                </td>
</tr>
</tbody>
</table></div>
<p>
          <tt class="computeroutput"><span class="identifier">rule</span></tt> is the rule we attach
          the handler to. In our case, we are attaching to the <tt class="computeroutput"><span class="identifier">xml</span></tt>
          rule.
        </p>
<p>
          <tt class="computeroutput"><span class="identifier">handler</span></tt> is the actual error
          handling function. It expects 4 arguments:
        </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Arg
                </p>
                </th>
<th>
                <p>
                  Description
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  first
                </p>
                </td>
<td>
                <p>
                  The position of the iterator when the rule with the handler was
                  entered.
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  last
                </p>
                </td>
<td>
                <p>
                  The end of input.
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  error-pos
                </p>
                </td>
<td>
                <p>
                  The actual position of the iterator where the error occurred.
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  what
                </p>
                </td>
<td>
                <p>
                  What failed: a string decribing the failure.
                </p>
                </td>
</tr>
</tbody>
</table></div>
<a name="spirit.qi_and_karma.tutorials.mini_xml___error_handling.expectation_points"></a><h5>
<a name="id482635"></a>
          <a href="qi_and_karma.html#spirit.qi_and_karma.tutorials.mini_xml___error_handling.expectation_points">Expectation
          Points</a>
        </h5>
<p>
          You might not have noticed it, but some of our expressions changed from
          using the <tt class="computeroutput"><span class="special">&gt;&gt;</span></tt> to <tt class="computeroutput"><span class="special">&gt;</span></tt>. Look, for example:
        </p>
<pre class="programlisting"><span class="identifier">end_tag</span> <span class="special">=</span>
        <span class="string">"&lt;/"</span>
    <span class="special">&gt;</span>   <span class="identifier">lit</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
    <span class="special">&gt;</span>   <span class="char">'&gt;'</span>
<span class="special">;</span>
</pre>
<p>
          What is it? It's the <span class="emphasis"><em>expectation</em></span> operator. You will
          have some "deterministic points" in the grammar. Those are the
          places where backtracking <span class="bold"><b>cannot</b></span> occur.
          For our example above, when you get a <tt class="computeroutput"><span class="string">"&lt;/"</span></tt>,
          you definitely must see a valid end-tag label next. It should be the one
          you got from the start-tag. After that, you definitely must have a <tt class="computeroutput"><span class="char">'&gt;'</span></tt> next. Otherwise, there is no point in
          proceeding forward and trying other branches, regardless where they are.
          The input is definitely erroneous. When this happens, an expectation_failure
          exception is thrown. Somewhere outward, the error handler will catch the
          exception.
        </p>
<p>
          Try building the parser: <a href="../../../example/qi/mini_xml2.cpp" target="_top">../../example/qi/mini_xml2.cpp</a>.
          You can find some examples in: <a href="../../../example/qi/mini_xml_samples" target="_top">../../example/qi/mini_xml_samples</a>
          for testing purposes. "4.toyxml" has an error in it:
        </p>
<pre class="programlisting"><span class="special">&lt;</span><span class="identifier">foo</span><span class="special">&gt;&lt;</span><span class="identifier">bar</span><span class="special">&gt;&lt;/</span><span class="identifier">foo</span><span class="special">&gt;&lt;/</span><span class="identifier">bar</span><span class="special">&gt;</span>
</pre>
<p>
          Running the example with this gives you:
        </p>
<pre class="programlisting"><span class="identifier">Error</span><span class="special">!</span> <span class="identifier">Expecting</span> <span class="string">"bar"</span> <span class="identifier">here</span><span class="special">:</span> <span class="string">"foo&gt;&lt;/bar&gt;"</span>
<span class="identifier">Error</span><span class="special">!</span> <span class="identifier">Expecting</span> <span class="identifier">end_tag</span> <span class="identifier">here</span><span class="special">:</span> <span class="string">"&lt;bar&gt;&lt;/foo&gt;&lt;/bar&gt;"</span>
<span class="special">-------------------------</span>
<span class="identifier">Parsing</span> <span class="identifier">failed</span>
<span class="special">-------------------------</span>
</pre>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright  2001-2008 Joel de Guzman,
      Hartmut Kaiser<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="qi_and_karma/abstracts.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
