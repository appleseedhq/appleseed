<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Inside Phoenix</title>
<link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.66.1">
<link rel="start" href="../index.html" title="Chapter 1. Phoenix 2.0">
<link rel="up" href="../index.html" title="Chapter 1. Phoenix 2.0">
<link rel="prev" href="algorithm.html" title="Algorithm">
<link rel="next" href="wrap_up.html" title="Wrap Up">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="algorithm.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="wrap_up.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="phoenix.inside_phoenix"></a><a href="inside_phoenix.html" title="Inside Phoenix">Inside Phoenix</a></h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail">Actors In Detail</a></span></dt>
<dt><span class="section"><a href="inside_phoenix.html#phoenix.inside_phoenix.actor_example">Actor Example</a></span></dt>
<dt><span class="section"><a href="inside_phoenix.html#phoenix.inside_phoenix.composites_in_detail">Composites
      In Detail</a></span></dt>
<dt><span class="section"><a href="inside_phoenix.html#phoenix.inside_phoenix.composing">Composing</a></span></dt>
<dt><span class="section"><a href="inside_phoenix.html#phoenix.inside_phoenix.extending">Extending</a></span></dt>
</dl></div>
<p>
      This chapter explains in more detail how the library operates. The information
      henceforth should not be necessary to those who are interested in just using
      the library. However, a microscopic view might prove to be beneficial to moderate
      to advanced programmers who wish to extend the library.
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.inside_phoenix.actors_in_detail"></a><a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail" title="Actors In Detail">Actors In Detail</a></h3></div></div></div>
<a name="phoenix.inside_phoenix.actors_in_detail.actor_concept"></a><h3>
<a name="id495846"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.actor_concept">Actor
        Concept</a>
      </h3>
<p>
        The main concept is the <tt class="computeroutput"><span class="identifier">Actor</span></tt>.
        Actors are function objects (that can accept 0 to N arguments (where N is
        a predefined maximum).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
          You can set <tt class="computeroutput"><span class="identifier">PHOENIX_LIMIT</span></tt>,
          the predefined maximum arity an actor can take. By default, <tt class="computeroutput"><span class="identifier">PHOENIX_LIMIT</span></tt> is set to 10.
        </p></td></tr>
</table></div>
<a name="phoenix.inside_phoenix.actors_in_detail.actor_template_class"></a><h3>
<a name="id495923"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.actor_template_class">actor
        template class</a>
      </h3>
<p>
        The <tt class="computeroutput"><span class="identifier">actor</span></tt> template class
        models the <tt class="computeroutput"><span class="identifier">Actor</span></tt> concept:
      </p>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Eval</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">actor</span> <span class="special">:</span> <span class="identifier">Eval</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">Eval</span> <span class="identifier">eval_type</span><span class="special">;</span>

    <span class="identifier">actor</span><span class="special">();</span>
    <span class="identifier">actor</span><span class="special">(</span><span class="identifier">Eval</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">base</span><span class="special">);</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T0</span><span class="special">&gt;</span>
    <span class="keyword">explicit</span> <span class="identifier">actor</span><span class="special">(</span><span class="identifier">T0</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">_0</span><span class="special">);</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">&gt;</span>
    <span class="identifier">actor</span><span class="special">(</span><span class="identifier">T0</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">_0</span><span class="special">,</span> <span class="identifier">T1</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">_1</span><span class="special">);</span>

    <span class="comment">// more constructors
</span>
    <span class="keyword">typename</span> <span class="identifier">apply_actor</span><span class="special">&lt;</span><span class="identifier">eval_type</span><span class="special">,</span> <span class="identifier">basic_environment</span><span class="special">&lt;&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="keyword">operator</span><span class="special">()()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T0</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">apply_actor</span><span class="special">&lt;</span><span class="identifier">eval_type</span><span class="special">,</span> <span class="identifier">basic_environment</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T0</span><span class="special">&amp;</span> <span class="identifier">_0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">apply_actor</span><span class="special">&lt;</span><span class="identifier">eval_type</span><span class="special">,</span> <span class="identifier">basic_environment</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">,</span> <span class="identifier">T1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T0</span><span class="special">&amp;</span> <span class="identifier">_0</span><span class="special">,</span> <span class="identifier">T1</span><span class="special">&amp;</span> <span class="identifier">_1</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="comment">// function call operators
</span><span class="special">};</span>
</pre>
<div class="table">
<a name="id496708"></a><p class="title"><b>Table 1.10. Actor Concept Requirements</b></p>
<table class="table" summary="Actor Concept Requirements">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
            <p>
              Expression
            </p>
            </th>
<th>
            <p>
              Result/Semantics
            </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">T</span><span class="special">::</span><span class="identifier">eval_type</span></tt>
            </p>
            </td>
<td>
            <p>
              The actor's Eval type
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">T</span><span class="special">()</span></tt>
            </p>
            </td>
<td>
            <p>
              Default Constructor
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">T</span><span class="special">(</span><span class="identifier">base</span><span class="special">)</span></tt>
            </p>
            </td>
<td>
            <p>
              Constructor from Eval
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">T</span><span class="special">(</span><span class="identifier">arg0</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">argN</span><span class="special">)</span></tt>
            </p>
            </td>
<td>
            <p>
              Pass through constructors
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">x</span><span class="special">(</span><span class="identifier">arg0</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">argN</span><span class="special">)</span></tt>
            </p>
            </td>
<td>
            <p>
              Function call operators
            </p>
            </td>
</tr>
</tbody>
</table>
</div>
<a name="phoenix.inside_phoenix.actors_in_detail.eval_concept"></a><h3>
<a name="id497020"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept">Eval
        Concept</a>
      </h3>
<p>
        The <tt class="computeroutput"><span class="identifier">actor</span></tt> template class
        has a single template parameter, <tt class="computeroutput"><span class="identifier">Eval</span></tt>,
        from which it derives from. While the <tt class="computeroutput"><span class="identifier">Actor</span></tt>
        concept represents a function, the <tt class="computeroutput"><span class="identifier">Eval</span></tt>
        concept represents the function body. The requirements for <tt class="computeroutput"><span class="identifier">Eval</span></tt> are intentionally kept simple, to
        make it easy to write models of the concept. We shall see an example in the
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actor_example" title="Actor Example">next section</a>.
      </p>
<div class="table">
<a name="id497115"></a><p class="title"><b>Table 1.11. Eval Concept Requirements</b></p>
<table class="table" summary="Eval Concept Requirements">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
            <p>
              Expression
            </p>
            </th>
<th>
            <p>
              Result/Semantics
            </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">env</span><span class="special">)</span></tt>
            </p>
            </td>
<td>
            <p>
              Evaluates the function (see Environment below)
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">T</span><span class="special">::</span><span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">Env</span><span class="special">&gt;::</span><span class="identifier">type</span></tt>
            </p>
            </td>
<td>
            <p>
              The return type of eval (see Environment below)
            </p>
            </td>
</tr>
</tbody>
</table>
</div>
<a name="phoenix.inside_phoenix.actors_in_detail.constructors"></a><h3>
<a name="id497287"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.constructors">Constructors</a>
      </h3>
<p>
        In addition to a default constructor and an constructor from a Eval object,
        there are templated (pass through) constructors for 1 to N arguments (N ==
        <tt class="computeroutput"><span class="identifier">PHOENIX_LIMIT</span></tt>). These constructors
        simply forward the arguments to the <tt class="computeroutput"><span class="identifier">base</span></tt>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top">
<p>
          <span class="bold"><b>Parametric Base Class Pattern</b></span>
        </p>
<p>
          Notice that actor derives from its template argument Eval. This is the
          inverse of the curiously recurring template pattern (CRTP). With the CRTP,
          a class, T, has a Derived template parameter that is assumed to be its
          subclass. The "parametric base class pattern" (PBCP), on the
          other hand, inverses the inheritance and makes a class, T, the derived
          class. Both CRTP and PBCP techniques have its pros and cons, which is outside
          the scope of this document. CRTP should really be renamed "parametric
          subclass pattern (PSCP), but again, that's another story.
        </p>
</td></tr>
</table></div>
<a name="phoenix.inside_phoenix.actors_in_detail.function_call_operators"></a><h3>
<a name="id497372"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.function_call_operators">Function
        Call Operators</a>
      </h3>
<p>
        There are N function call operators for 0 to N arguments (N == <tt class="computeroutput"><span class="identifier">PHOENIX_LIMIT</span></tt>). The actor class accepts
        the arguments and forwards the arguments to the actor's base <tt class="computeroutput"><span class="identifier">Eval</span></tt> for evaluation.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top">
<p>
          <span class="bold"><b>Forwarding Function Problem</b></span>
        </p>
<p>
          The function call operators cannot accept non-const temporaries and literal
          constants. There is a known issue with current C++ called the "<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm" target="_top">Forwarding
          Function Problem</a>". The problem is that given an arbitrary
          function <tt class="computeroutput"><span class="identifier">F</span></tt>, using current
          C++ language rules, one cannot create a forwarding function <tt class="computeroutput"><span class="identifier">FF</span></tt> that transparently assumes the arguments
          of <tt class="computeroutput"><span class="identifier">F</span></tt>. Disallowing non-const
          rvalues arguments partially solves the problem but prohibits code such
          as <tt class="computeroutput"><span class="identifier">f</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">,</span> <span class="number">3</span><span class="special">);</span></tt>.
        </p>
</td></tr>
</table></div>
<a name="phoenix.inside_phoenix.actors_in_detail.environment"></a><h3>
<a name="id497544"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.environment">Environment</a>
      </h3>
<p>
        On an actor function call, before calling the actor's <tt class="computeroutput"><span class="identifier">Eval</span><span class="special">::</span><span class="identifier">eval</span></tt>
        for evaluation, the actor creates an <span class="emphasis"><em><span class="bold"><b>environment</b></span></em></span>.
        Basically, the environment packages the arguments in a tuple. The <tt class="computeroutput"><span class="identifier">Environment</span></tt> is a concept, of which, the
        <tt class="computeroutput"><span class="identifier">basic_environment</span></tt> template
        class is a model of.
      </p>
<div class="table">
<a name="id497623"></a><p class="title"><b>Table 1.12. Environment Concept Requirements</b></p>
<table class="table" summary="Environment Concept Requirements">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
            <p>
              Expression
            </p>
            </th>
<th>
            <p>
              Result/Semantics
            </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">x</span><span class="special">.</span><span class="identifier">args</span><span class="special">()</span></tt>
            </p>
            </td>
<td>
            <p>
              The arguments in a tie (a tuple of references)
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">T</span><span class="special">::</span><span class="identifier">args_type</span></tt>
            </p>
            </td>
<td>
            <p>
              The arguments' types in an MPL sequence
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">T</span><span class="special">::</span><span class="identifier">tie_type</span></tt>
            </p>
            </td>
<td>
            <p>
              The tie (tuple of references) type
            </p>
            </td>
</tr>
</tbody>
</table>
</div>
<p>
        Schematically:
      </p>
<p>
        <span class="inlinemediaobject"><img src="../images/funnel_in.png" alt="funnel_in"></span>
      </p>
<p>
        Other parts of the library (e.g. the scope module) extends the <tt class="computeroutput"><span class="identifier">Environment</span></tt> concept to hold other information
        such as local variables, etc.
      </p>
<a name="phoenix.inside_phoenix.actors_in_detail.apply_actor"></a><h3>
<a name="id497839"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.apply_actor">apply_actor</a>
      </h3>
<p>
        <tt class="computeroutput"><span class="identifier">apply_actor</span></tt> is a standard
        MPL style metafunction that simply calls the Action's <tt class="computeroutput"><span class="identifier">result</span></tt>
        nested metafunction:
      </p>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Action</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Env</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">apply_actor</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Action</span><span class="special">::</span><span class="keyword">template</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">Env</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
        After evaluating the arguments and doing some computation, the <tt class="computeroutput"><span class="identifier">eval</span></tt> member function returns something
        back to the client. To do this, the forwarding function (the actor's <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>)
        needs to know the return type of the eval member function that it is calling.
        For this purpose, models of <tt class="computeroutput"><span class="identifier">Eval</span></tt>
        are required to provide a nested template class:
      </p>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Env</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>
</pre>
<p>
        This nested class provides the result type information returned by the <tt class="computeroutput"><span class="identifier">Eval</span></tt>'s <tt class="computeroutput"><span class="identifier">eval</span></tt>
        member function. The nested template class <tt class="computeroutput"><span class="identifier">result</span></tt>
        should have a typedef <tt class="computeroutput"><span class="identifier">type</span></tt>
        that reflects the return type of its member function <tt class="computeroutput"><span class="identifier">eval</span></tt>.
      </p>
<p>
        For reference, here's a typical <tt class="computeroutput"><span class="identifier">actor</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></tt> that accepts two arguments:
      </p>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">apply_actor</span><span class="special">&lt;</span><span class="identifier">eval_type</span><span class="special">,</span> <span class="identifier">basic_environment</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">,</span> <span class="identifier">T1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T0</span><span class="special">&amp;</span> <span class="identifier">_0</span><span class="special">,</span> <span class="identifier">T1</span><span class="special">&amp;</span> <span class="identifier">_1</span><span class="special">)</span> <span class="keyword">const</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">eval_type</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">basic_environment</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">,</span> <span class="identifier">T1</span><span class="special">&gt;(</span><span class="identifier">_0</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<a name="phoenix.inside_phoenix.actors_in_detail.actor_result"></a><h3>
<a name="id498520"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.actor_result">actor_result</a>
      </h3>
<p>
        For reasons of symmetry to the family of <tt class="computeroutput"><span class="identifier">actor</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></tt> there is a special metafunction usable
        for actor result type calculation named <tt class="computeroutput"><span class="identifier">actor_result</span></tt>.
        This metafunction allows us to directly to specify the types of the parameters
        to be passed to the <tt class="computeroutput"><span class="identifier">actor</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></tt> function. Here's a typical <tt class="computeroutput"><span class="identifier">actor_result</span></tt> that accepts two arguments:
      </p>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Action</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">actor_result</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">basic_environment</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">,</span> <span class="identifier">T1</span><span class="special">&gt;</span> <span class="identifier">env_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Action</span><span class="special">::</span><span class="keyword">template</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">env_type</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.inside_phoenix.actor_example"></a><a href="inside_phoenix.html#phoenix.inside_phoenix.actor_example" title="Actor Example">Actor Example</a></h3></div></div></div>
<p>
        Let us see a very simple prototypical example of an actor. This is not a
        toy example. This is actually part of the library. Remember the <a href="primitives.html#phoenix.primitives.references" title="References"><tt class="computeroutput"><span class="identifier">reference</span></tt></a>?.
      </p>
<p>
        First, we have a model of the <tt class="computeroutput"><span class="identifier">Eval</span></tt>
        concept: the <tt class="computeroutput"><span class="identifier">reference</span></tt>:
      </p>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">reference</span>
<span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Env</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="identifier">reference</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">arg</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">arg</span><span class="special">)</span> <span class="special">{}</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Env</span><span class="special">&gt;</span>
    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">eval</span><span class="special">(</span><span class="identifier">Env</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">ref</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">ref</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
        Models of <tt class="computeroutput"><span class="identifier">Eval</span></tt> are never
        created directly and its instances never exist alone. We have to wrap it
        inside the <tt class="computeroutput"><span class="identifier">actor</span></tt> template
        class to be useful. The <tt class="computeroutput"><span class="identifier">ref</span></tt>
        template function does this for us:
      </p>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">actor</span><span class="special">&lt;</span><span class="identifier">reference</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="keyword">const</span>
<span class="identifier">ref</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">reference</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        The <tt class="computeroutput"><span class="identifier">reference</span></tt> template class
        conforms to the <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept"><tt class="computeroutput"><span class="identifier">Eval</span></tt></a> concept. It has a nested <tt class="computeroutput"><span class="identifier">result</span></tt> metafunction that reflects the return
        type of its <tt class="computeroutput"><span class="identifier">eval</span></tt> member function,
        which peforms the actual function. <tt class="computeroutput"><span class="identifier">reference</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></tt>
        stores a reference to a <tt class="computeroutput"><span class="identifier">T</span></tt>.
        Its <tt class="computeroutput"><span class="identifier">eval</span></tt> member function
        simply returns the reference. It does not make use of the environment <tt class="computeroutput"><span class="identifier">Env</span></tt>.
      </p>
<p>
        <span class="emphasis"><em>Pretty simple...</em></span>
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.inside_phoenix.composites_in_detail"></a><a href="inside_phoenix.html#phoenix.inside_phoenix.composites_in_detail" title="Composites
      In Detail">Composites
      In Detail</a></h3></div></div></div>
<p>
        We stated before that composites are actors that are composed of zero or
        more actors (see <a href="composite.html" title="Composite">Composite</a>). This
        is not quite accurate. The definition was sufficient at that point where
        we opted to keep things simple and not bury the reader with details which
        she might not need anyway.
      </p>
<p>
        Actually, a composite is a model of the <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept"><tt class="computeroutput"><span class="identifier">Eval</span></tt></a> concept (more on this later).
        At the same time, it is also composed of 0..N (where N is a predefined maximum)
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept"><tt class="computeroutput"><span class="identifier">Eval</span></tt></a> instances and an eval policy.
        The individual <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept"><tt class="computeroutput"><span class="identifier">Eval</span></tt></a> instances are stored in a tuple.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
          In a sense, the original definition of "composite", more or less,
          will do just fine because <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept"><tt class="computeroutput"><span class="identifier">Eval</span></tt></a> instances never exist alone
          and are always wrapped in an <tt class="computeroutput"><span class="identifier">actor</span></tt>
          template class which inherits from it anyway. The resulting actor IS-AN
          <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept"><tt class="computeroutput"><span class="identifier">Eval</span></tt></a>.
        </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
          You can set <tt class="computeroutput"><span class="identifier">PHOENIX_COMPOSITE_LIMIT</span></tt>,
          the predefined maximum <tt class="computeroutput"><span class="identifier">Eval</span></tt>s
          (actors) a composite can take. By default, <tt class="computeroutput"><span class="identifier">PHOENIX_COMPOSITE_LIMIT</span></tt>
          is set to <tt class="computeroutput"><span class="identifier">PHOENIX_LIMIT</span></tt>
          (See <a href="actors.html" title="Actors">Actors</a>).
        </p></td></tr>
</table></div>
<a name="phoenix.inside_phoenix.composites_in_detail.composite_template_class"></a><h2>
<a name="id499816"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.composites_in_detail.composite_template_class">composite
        template class</a>
      </h2>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">EvalPolicy</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">EvalTuple</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite</span> <span class="special">:</span> <span class="identifier">EvalTuple</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">EvalTuple</span> <span class="identifier">base_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">EvalPolicy</span> <span class="identifier">eval_policy_type</span><span class="special">;</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Env</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="identifier">composite</span><span class="special">();</span>
    <span class="identifier">composite</span><span class="special">(</span><span class="identifier">base_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">actors</span><span class="special">);</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">U0</span><span class="special">&gt;</span>
    <span class="identifier">composite</span><span class="special">(</span><span class="identifier">U0</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">_0</span><span class="special">);</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">U0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">U1</span><span class="special">&gt;</span>
    <span class="identifier">composite</span><span class="special">(</span><span class="identifier">U0</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">_0</span><span class="special">,</span> <span class="identifier">U1</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">_1</span><span class="special">);</span>

    <span class="comment">// more constructors
</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Env</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">Env</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="identifier">eval</span><span class="special">(</span><span class="identifier">Env</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">env</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<a name="phoenix.inside_phoenix.composites_in_detail.evaltuple"></a><h2>
<a name="id500422"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.composites_in_detail.evaltuple">EvalTuple</a>
      </h2>
<p>
        <tt class="computeroutput"><span class="identifier">EvalTuple</span></tt>, holds all the
        <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept"><tt class="computeroutput"><span class="identifier">Eval</span></tt></a> instances. The <tt class="computeroutput"><span class="identifier">composite</span></tt> template class inherits from
        it. In addition to a default constructor and a constructor from an <tt class="computeroutput"><span class="identifier">EvalTuple</span></tt> object, there are templated (pass
        through) constructors for 1 to N arguments (again, where N == <tt class="computeroutput"><span class="identifier">PHOENIX_COMPOSITE_LIMIT</span></tt>). These constructors
        simply forward the arguments to the <tt class="computeroutput"><span class="identifier">EvalTuple</span></tt>
        base class.
      </p>
<a name="phoenix.inside_phoenix.composites_in_detail.evalpolicy"></a><h2>
<a name="id500533"></a>
        <a href="inside_phoenix.html#phoenix.inside_phoenix.composites_in_detail.evalpolicy">EvalPolicy</a>
      </h2>
<p>
        The composite's <tt class="computeroutput"><span class="identifier">eval</span></tt> member
        function calls its <tt class="computeroutput"><span class="identifier">EvalPolicy</span></tt>'s
        <tt class="computeroutput"><span class="identifier">eval</span></tt> member function (a static
        member function) passing in the <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.environment">environment</a>
        and each of its actors, in parallel. The following diagram illustrates what's
        happening:
      </p>
<p>
        <span class="inlinemediaobject"><img src="../images/funnel_out.png" alt="funnel_out"></span>
      </p>
<div class="table">
<a name="id500623"></a><p class="title"><b>Table 1.13. EvalPolicy Requirements</b></p>
<table class="table" summary="EvalPolicy Requirements">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
            <p>
              Expression
            </p>
            </th>
<th>
            <p>
              Result/Semantics
            </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">x</span><span class="special">.</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">RT</span><span class="special">&gt;(</span><span class="identifier">env</span><span class="special">,</span> <span class="identifier">eval0</span><span class="special">,</span>
              <span class="identifier">eval1</span><span class="special">,</span>
              <span class="special">...,</span> <span class="identifier">evalN</span><span class="special">)</span></tt>
            </p>
            </td>
<td>
            <p>
              Evaluate the composite
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">T</span><span class="special">::</span><span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">Env</span><span class="special">,</span> <span class="identifier">Eval0</span><span class="special">,</span>
              <span class="identifier">Eval1</span><span class="special">,</span>
              <span class="identifier">Eval2</span><span class="special">,</span>
              <span class="special">...,</span> <span class="identifier">EvalN</span><span class="special">&gt;::</span><span class="identifier">type</span></tt>
            </p>
            </td>
<td>
            <p>
              The return type of eval
            </p>
            </td>
</tr>
</tbody>
</table>
</div>
<p>
        The <tt class="computeroutput"><span class="identifier">EvalPolicy</span></tt> is expected
        to have a nested template class <tt class="computeroutput"><span class="identifier">result</span></tt>
        which has a typedef <tt class="computeroutput"><span class="identifier">type</span></tt>
        that reflects the return type of its member function <tt class="computeroutput"><span class="identifier">eval</span></tt>.
        Here's a typical example of the composite's eval member function for a 2-actor
        composite:
      </p>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Env</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">Env</span><span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">eval</span><span class="special">(</span><span class="identifier">Env</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">env</span><span class="special">)</span> <span class="keyword">const</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">Env</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">return_type</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">EvalPolicy</span><span class="special">::</span><span class="keyword">template</span>
        <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">return_type</span><span class="special">&gt;(</span>
            <span class="identifier">env</span>
          <span class="special">,</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(*</span><span class="keyword">this</span><span class="special">)</span>   <span class="comment">// gets the 0th element from EvalTuple
</span>          <span class="special">,</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(*</span><span class="keyword">this</span><span class="special">));</span> <span class="comment">// gets the 1st element from EvalTuple
</span><span class="special">}</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.inside_phoenix.composing"></a><a href="inside_phoenix.html#phoenix.inside_phoenix.composing" title="Composing">Composing</a></h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="inside_phoenix.html#phoenix.inside_phoenix.composing.compose">compose</a></span></dt>
<dt><span class="section"><a href="inside_phoenix.html#phoenix.inside_phoenix.composing.as_composite">as_composite</a></span></dt>
<dt><span class="section"><a href="inside_phoenix.html#phoenix.inside_phoenix.composing.composite_example">Composite
        Example</a></span></dt>
</dl></div>
<p>
        Composites are never instantiated directly. Front end expression templates
        are used to generate the composites. Using expression templates, we implement
        a DSEL (Domain Specific Embedded Language) that mimicks native C++. You've
        seen this DSEL in action in the preceding sections. It is most evident in
        the <a href="composite.html#phoenix.composite.statement" title="Statement">Statement</a> section.
      </p>
<p>
        There are some facilities in the library to make composition of composites
        easier. We have a set of overloaded <tt class="computeroutput"><span class="identifier">compose</span></tt>
        functions and an <tt class="computeroutput"><span class="identifier">as_composite</span></tt>
        metafunction. Together, these helpers make composing a breeze. We'll provide
        an <a href="inside_phoenix.html#phoenix.inside_phoenix.composing.composite_example" title="Composite
        Example">example
        of a composite</a> later to see why.
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.inside_phoenix.composing.compose"></a><a href="inside_phoenix.html#phoenix.inside_phoenix.composing.compose" title="compose">compose</a></h4></div></div></div>
<pre class="programlisting">
<span class="identifier">compose</span><span class="special">&lt;</span><span class="identifier">EvalPolicy</span><span class="special">&gt;(</span><span class="identifier">arg0</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">arg2</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">argN</span><span class="special">);</span>
</pre>
<p>
          Given an <a href="inside_phoenix.html#phoenix.inside_phoenix.composites_in_detail.evalpolicy"><tt class="computeroutput"><span class="identifier">EvalPolicy</span></tt></a> and some arguments
          <tt class="computeroutput"><span class="identifier">arg0</span></tt>...argN, returns a
          proper <tt class="computeroutput"><span class="identifier">composite</span></tt>. The arguments
          may or may not be phoenix actors (primitives of composites). If not, the
          arguments are converted to actors appropriately. For example:
        </p>
<pre class="programlisting">
<span class="identifier">compose</span><span class="special">&lt;</span><span class="identifier">X</span><span class="special">&gt;(</span><span class="number">3</span><span class="special">)</span>
</pre>
<p>
          converts the argument <tt class="computeroutput"><span class="number">3</span></tt> to
          an <tt class="computeroutput"><span class="identifier">actor</span><span class="special">&lt;</span><span class="identifier">value</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;(</span><span class="number">3</span><span class="special">)</span></tt>.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.inside_phoenix.composing.as_composite"></a><a href="inside_phoenix.html#phoenix.inside_phoenix.composing.as_composite" title="as_composite">as_composite</a></h4></div></div></div>
<pre class="programlisting">
<span class="identifier">as_composite</span><span class="special">&lt;</span><span class="identifier">EvalPolicy</span><span class="special">,</span> <span class="identifier">Arg0</span><span class="special">,</span> <span class="identifier">Arg1</span><span class="special">,</span> <span class="identifier">Arg2</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">ArgN</span><span class="special">&gt;::</span><span class="identifier">type</span>
</pre>
<p>
          This is the metafunction counterpart of <tt class="computeroutput"><span class="identifier">compose</span></tt>.
          Given an <a href="inside_phoenix.html#phoenix.inside_phoenix.composites_in_detail.evalpolicy"><tt class="computeroutput"><span class="identifier">EvalPolicy</span></tt></a> and some argument types
          <tt class="computeroutput"><span class="identifier">Arg0</span></tt>...ArgN, returns a
          proper <tt class="computeroutput"><span class="identifier">composite</span></tt> type.
          For example:
        </p>
<pre class="programlisting">
<span class="identifier">as_composite</span><span class="special">&lt;</span><span class="identifier">X</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span>
</pre>
<p>
          is the composite type of the <tt class="computeroutput"><span class="identifier">compose</span><span class="special">&lt;</span><span class="identifier">X</span><span class="special">&gt;(</span><span class="number">3</span><span class="special">)</span></tt>
          expression above.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.inside_phoenix.composing.composite_example"></a><a href="inside_phoenix.html#phoenix.inside_phoenix.composing.composite_example" title="Composite
        Example">Composite
        Example</a></h4></div></div></div>
<p>
          Now, let's examine an example. Again, this is not a toy example. This is
          actually part of the library. Remember the <a href="composite.html#phoenix.composite.statement.while__statement" title="while_
        Statement"><tt class="computeroutput"><span class="identifier">while_</span></tt></a> lazy statement? Putting
          together everything we've learned so far, we will present it here in its
          entirety (verbatim):
        </p>
<pre class="programlisting">
<span class="keyword">struct</span> <span class="identifier">while_eval</span>
<span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Env</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Cond</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Do</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RT</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Env</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Cond</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Do</span><span class="special">&gt;</span>
    <span class="keyword">static</span> <span class="keyword">void</span>
    <span class="identifier">eval</span><span class="special">(</span><span class="identifier">Env</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">env</span><span class="special">,</span> <span class="identifier">Cond</span><span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">,</span> <span class="identifier">Do</span><span class="special">&amp;</span> <span class="identifier">do_</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">while</span> <span class="special">(</span><span class="identifier">cond</span><span class="special">.</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">env</span><span class="special">))</span>
            <span class="identifier">do_</span><span class="special">.</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">env</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Cond</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">while_gen</span>
<span class="special">{</span>
    <span class="identifier">while_gen</span><span class="special">(</span><span class="identifier">Cond</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">cond</span><span class="special">(</span><span class="identifier">cond</span><span class="special">)</span> <span class="special">{}</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Do</span><span class="special">&gt;</span>
    <span class="identifier">actor</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">as_composite</span><span class="special">&lt;</span><span class="identifier">while_eval</span><span class="special">,</span> <span class="identifier">Cond</span><span class="special">,</span> <span class="identifier">Do</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
    <span class="keyword">operator</span><span class="special">[](</span><span class="identifier">Do</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">do_</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">compose</span><span class="special">&lt;</span><span class="identifier">while_eval</span><span class="special">&gt;(</span><span class="identifier">cond</span><span class="special">,</span> <span class="identifier">do_</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="identifier">Cond</span> <span class="identifier">cond</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Cond</span><span class="special">&gt;</span>
<span class="identifier">while_gen</span><span class="special">&lt;</span><span class="identifier">Cond</span><span class="special">&gt;</span>
<span class="identifier">while_</span><span class="special">(</span><span class="identifier">Cond</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">while_gen</span><span class="special">&lt;</span><span class="identifier">Cond</span><span class="special">&gt;(</span><span class="identifier">cond</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          <tt class="computeroutput"><span class="identifier">while_eval</span></tt> is an example
          of an <a href="inside_phoenix.html#phoenix.inside_phoenix.composites_in_detail.evalpolicy"><tt class="computeroutput"><span class="identifier">EvalPolicy</span></tt></a>. <tt class="computeroutput"><span class="identifier">while_gen</span></tt>
          and <tt class="computeroutput"><span class="identifier">while_</span></tt> are the expression
          template front ends. Let's break this apart to understand what's happening.
          Let's start at the bottom. It's easier that way.
        </p>
<p>
          When you write:
        </p>
<pre class="programlisting">
<span class="identifier">while_</span><span class="special">(</span><span class="identifier">cond</span><span class="special">)</span>
</pre>
<p>
          we generate an instance of <tt class="computeroutput"><span class="identifier">while_gen</span><span class="special">&lt;</span><span class="identifier">Cond</span><span class="special">&gt;</span></tt>, where <tt class="computeroutput"><span class="identifier">Cond</span></tt>
          is the type of <tt class="computeroutput"><span class="identifier">cond</span></tt>. <tt class="computeroutput"><span class="identifier">cond</span></tt> can be an arbitrarily complex actor
          expression. The <tt class="computeroutput"><span class="identifier">while_gen</span></tt>
          template class has an <tt class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></tt> accepting another expression. If we write:
        </p>
<pre class="programlisting">
<span class="identifier">while_</span><span class="special">(</span><span class="identifier">cond</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">do_</span>
<span class="special">]</span>
</pre>
<p>
          it will generate a proper composite with the type:
        </p>
<pre class="programlisting">
<span class="identifier">as_composite</span><span class="special">&lt;</span><span class="identifier">while_eval</span><span class="special">,</span> <span class="identifier">Cond</span><span class="special">,</span> <span class="identifier">Do</span><span class="special">&gt;::</span><span class="identifier">type</span>
</pre>
<p>
          where <tt class="computeroutput"><span class="identifier">Cond</span></tt> is the type
          of <tt class="computeroutput"><span class="identifier">cond</span></tt> and <tt class="computeroutput"><span class="identifier">Do</span></tt> is the type of <tt class="computeroutput"><span class="identifier">do_</span></tt>.
          Notice how we are using phoenix's <a href="inside_phoenix.html#phoenix.inside_phoenix.composing" title="Composing">composition</a>
          (<tt class="computeroutput"><span class="identifier">compose</span></tt> and <tt class="computeroutput"><span class="identifier">as_composite</span></tt>) mechanisms here
        </p>
<pre class="programlisting">
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Do</span><span class="special">&gt;</span>
<span class="identifier">actor</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">as_composite</span><span class="special">&lt;</span><span class="identifier">while_eval</span><span class="special">,</span> <span class="identifier">Cond</span><span class="special">,</span> <span class="identifier">Do</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="keyword">operator</span><span class="special">[](</span><span class="identifier">Do</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">do_</span><span class="special">)</span> <span class="keyword">const</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">compose</span><span class="special">&lt;</span><span class="identifier">while_eval</span><span class="special">&gt;(</span><span class="identifier">cond</span><span class="special">,</span> <span class="identifier">do_</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          Finally, the <tt class="computeroutput"><span class="identifier">while_eval</span></tt>
          does its thing:
        </p>
<pre class="programlisting">
<span class="keyword">while</span> <span class="special">(</span><span class="identifier">cond</span><span class="special">.</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">env</span><span class="special">))</span>
    <span class="identifier">do_</span><span class="special">.</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">env</span><span class="special">);</span>
</pre>
<p>
          <tt class="computeroutput"><span class="identifier">cond</span></tt> and <tt class="computeroutput"><span class="identifier">do_</span></tt>, at this point, are instances of
          <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept"><tt class="computeroutput"><span class="identifier">Eval</span></tt></a>. <tt class="computeroutput"><span class="identifier">cond</span></tt>
          and <tt class="computeroutput"><span class="identifier">do_</span></tt> are the <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.eval_concept"><tt class="computeroutput"><span class="identifier">Eval</span></tt></a> elements held by the composite's
          <a href="inside_phoenix.html#phoenix.inside_phoenix.composites_in_detail.evaltuple"><tt class="computeroutput"><span class="identifier">EvalTuple</span></tt></a>. <tt class="computeroutput"><span class="identifier">env</span></tt>
          is the <a href="inside_phoenix.html#phoenix.inside_phoenix.actors_in_detail.environment"><tt class="computeroutput"><span class="identifier">Environment</span></tt></a>.
        </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.inside_phoenix.extending"></a><a href="inside_phoenix.html#phoenix.inside_phoenix.extending" title="Extending">Extending</a></h3></div></div></div>
<p>
        We've shown how it is very easy to extend phoenix by writing new primitives
        and composites. The modular design of Phoenix makes it extremely extensible.
        We have seen that layer upon layer, the whole library is built on a solid
        foundation. There are only a few simple well designed concepts that are laid
        out like bricks. Overall, the library is designed to be extended. Everything
        above the core layer can in fact be considered just as extensions to the
        library. This modular design was inherited from the <a href="http://spirit.sourceforge.net" target="_top">Spirit</a>
        inline parser library.
      </p>
<p>
        Extension is non-intrusive. And, whenever a component or module is extended,
        the new extension automatically becomes a first class citizen and is automatically
        recognized by all modules and components in the library.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2002-2005 Joel
      de Guzman, Dan Marsden<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="algorithm.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="wrap_up.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
