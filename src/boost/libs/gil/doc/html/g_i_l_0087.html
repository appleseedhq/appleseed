<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  --
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://opensource.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://opensource.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>Generic Image Library  : gil_concept.hpp File Reference</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="opensource.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<div class="qindex"><a class="qindex" href="index.html">Modules</a> 
                  | <a class="qindex" href="classes.html">Alphabetical List</a> 
                  | <a class="qindex" href="annotated.html">Class List</a> 
                  | <a class="qindex" href="dirs.html">Directories</a> 
                  | <a class="qindex" href="files.html">File List</a> 
                  | <a class="qindex" href="globals.html">File Members</a> 
                  | <a class="qindex" href="../index.html">GIL Home Page</a> 
</div>
<!-- End Header -->
<!-- Generated by Doxygen 1.4.4 -->
<div class="nav">
<a class="el" href="dir_000000.html">boost</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000001.html">gil</a></div>
<h1>gil_concept.hpp File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Concept check classes for GIL concepts. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Lubomir Bourdev and Hailin Jin <br>
 Adobe Systems Incorporated </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2005-2007 <br>
 Last updated on February 12, 2007</dd></dl>

<p>
<code>#include &lt;functional&gt;</code><br>
<code>#include &quot;<a class="el" href="g_i_l_0088.html">gil_config.hpp</a>&quot;</code><br>
<code>#include &lt;boost/type_traits.hpp&gt;</code><br>
<code>#include &lt;boost/utility/enable_if.hpp&gt;</code><br>
<code>#include &lt;boost/concept_check.hpp&gt;</code><br>
<code>#include &lt;boost/iterator/iterator_concepts.hpp&gt;</code><br>
<code>#include &lt;boost/mpl/and.hpp&gt;</code><br>
<code>#include &lt;boost/mpl/size.hpp&gt;</code><br>

<p>
<a href="g_i_l_0086.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost.html">boost</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><b>boost::gil</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><b>boost::gil::detail</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0281.html">DefaultConstructible</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0279.html">CopyConstructible</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0257.html">Assignable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0283.html">EqualityComparable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0373.html">SameType</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0377.html">Swappable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0371.html">Regular</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0309.html">Metafunction</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0357.html">PointNDConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional point concept.  <a href="g_i_l_0357.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0355.html">Point2DConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional point concept  <a href="g_i_l_0355.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0275.html">ColorSpaceConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color space type concept.  <a href="g_i_l_0275.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0277.html">ColorSpacesCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two color spaces are compatible if they are the same.  <a href="g_i_l_0277.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0263.html">ChannelMappingConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Channel mapping concept.  <a href="g_i_l_0263.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0259.html">ChannelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A channel is the building block of a color. Color is defined as a mixture of primary colors and a channel defines the degree to which each primary color is used in the mixture.  <a href="g_i_l_0259.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0311.html">MutableChannelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A channel that allows for modifying its value.  <a href="g_i_l_0311.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0265.html">ChannelValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A channel that supports default construction.  <a href="g_i_l_0265.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0427.html">channels_are_compatible</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate metafunction returning whether two channels are compatible<p>
Channels are considered compatible if their value types (ignoring constness and references) are the same.  <a href="g_i_l_0427.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0267.html">ChannelsCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Channels are compatible if their associated value types (ignoring constness and references) are the same.  <a href="g_i_l_0267.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0261.html">ChannelConvertibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A channel is convertible to another one if the <code>channel_convert</code> algorithm is defined for the two channels.  <a href="g_i_l_0261.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0269.html">ColorBaseConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A color base is a container of color elements (such as channels, channel references or channel pointers).  <a href="g_i_l_0269.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0313.html">MutableColorBaseConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color base which allows for modifying its elements.  <a href="g_i_l_0313.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0271.html">ColorBaseValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color base that also has a default-constructor. Refines <a class="el" href="g_i_l_0371.html">Regular</a>.  <a href="g_i_l_0271.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color base whose elements all have the same type.  <a href="g_i_l_0291.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0315.html">MutableHomogeneousColorBaseConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous color base that allows for modifying its elements.  <a href="g_i_l_0315.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous color base that also has a default constructor. Refines <a class="el" href="g_i_l_0371.html">Regular</a>.  <a href="g_i_l_0293.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0273.html">ColorBasesCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two color bases are compatible if they have the same color space and their elements are compatible, semantic-pairwise.  <a href="g_i_l_0273.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0339.html">PixelBasedConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for all pixel-based GIL constructs, such as pixels, iterators, locators, views and images whose value type is a pixel.  <a href="g_i_l_0339.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0295.html">HomogeneousPixelBasedConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for homogeneous pixel-based GIL constructs.  <a href="g_i_l_0295.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0341.html">PixelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel concept - A color base whose elements are channels.  <a href="g_i_l_0341.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0323.html">MutablePixelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel concept that allows for changing its channels.  <a href="g_i_l_0323.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0297.html">HomogeneousPixelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous pixel concept.  <a href="g_i_l_0297.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0317.html">MutableHomogeneousPixelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous pixel concept that allows for changing its channels.  <a href="g_i_l_0317.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0351.html">PixelValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel concept that is a <a class="el" href="g_i_l_0371.html">Regular</a> type.  <a href="g_i_l_0351.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0299.html">HomogeneousPixelValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous pixel concept that is a <a class="el" href="g_i_l_0371.html">Regular</a> type.  <a href="g_i_l_0299.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0601.html">pixels_are_compatible</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether two pixels are compatible.  <a href="g_i_l_0601.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0353.html">PixelsCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for pixel compatibility Pixels are compatible if their channels and color space types are compatible. Compatible pixels can be assigned and copy constructed from one another.  <a href="g_i_l_0353.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0343.html">PixelConvertibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel convertible concept.  <a href="g_i_l_0343.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a unary function object that can be invoked upon dereferencing a pixel iterator.  <a href="g_i_l_0345.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for iterators, locators and views that can define a type just like the given iterator/locator/view, except it supports runtime specified step along the X navigation.  <a href="g_i_l_0285.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for locators and views that can define a type just like the given locator or view, except it supports runtime specified step along the Y navigation.  <a href="g_i_l_0287.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0289.html">HasTransposedTypeConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for locators and views that can define a type just like the given locator or view, except X and Y is swapped.  <a href="g_i_l_0289.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An STL random access traversal iterator over a model of <a class="el" href="g_i_l_0341.html">PixelConcept</a>.  <a href="g_i_l_0347.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0325.html">MutablePixelIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel iterator that allows for changing its pixel.  <a href="g_i_l_0325.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0307.html">MemoryBasedIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept of a random-access iterator that can be advanced in memory units (bytes or bits).  <a href="g_i_l_0307.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0375.html">StepIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Step iterator concept.  <a href="g_i_l_0375.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0337.html">MutableStepIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Step iterator that allows for modifying its current value.  <a href="g_i_l_0337.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0305.html">IteratorAdaptorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator adaptor is a forward iterator adapting another forward iterator.  <a href="g_i_l_0305.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0321.html">MutableIteratorAdaptorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator adaptor that is mutable.  <a href="g_i_l_0321.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0369.html">RandomAccessNDLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional locator over immutable values.  <a href="g_i_l_0369.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0363.html">RandomAccess2DLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional locator over immutable values  <a href="g_i_l_0363.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0349.html">PixelLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GIL's 2-dimensional locator over immutable GIL pixels.  <a href="g_i_l_0349.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0335.html">MutableRandomAccessNDLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional locator over mutable pixels.  <a href="g_i_l_0335.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0331.html">MutableRandomAccess2DLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional locator over mutable pixels  <a href="g_i_l_0331.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0327.html">MutablePixelLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GIL's 2-dimensional locator over mutable GIL pixels.  <a href="g_i_l_0327.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0367.html">RandomAccessNDImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional view over immutable values.  <a href="g_i_l_0367.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0361.html">RandomAccess2DImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional view over immutable values  <a href="g_i_l_0361.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0303.html">ImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GIL's 2-dimensional view over immutable GIL pixels.  <a href="g_i_l_0303.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0333.html">MutableRandomAccessNDImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional view over mutable values.  <a href="g_i_l_0333.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0329.html">MutableRandomAccess2DImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional view over mutable values  <a href="g_i_l_0329.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0319.html">MutableImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GIL's 2-dimensional view over mutable GIL pixels.  <a href="g_i_l_0319.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0630.html">views_are_compatible</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether two views are compatible.  <a href="g_i_l_0630.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0379.html">ViewsCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Views are compatible if they have the same color spaces and compatible channel values. Constness and layout are not important for compatibility.  <a href="g_i_l_0379.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0365.html">RandomAccessNDImageConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional container of values.  <a href="g_i_l_0365.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0359.html">RandomAccess2DImageConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional container of values  <a href="g_i_l_0359.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0301.html">ImageConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional image whose value type models <a class="el" href="g_i_l_0351.html">PixelValueConcept</a>  <a href="g_i_l_0301.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0"></a><!-- doxytag: member="gil_concept.hpp::GIL_CLASS_REQUIRE" ref="a0" args="(T, NS, C)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GIL_CLASS_REQUIRE</b>(T, NS, C)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a87"></a><!-- doxytag: member="gil_concept.hpp::channel_convert" ref="a87" args="(srcT val)" -->
template&lt;typename dstT, typename srcT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">channel_traits&lt; dstT &gt;::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>boost::gil::channel_convert</b> (srcT val)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga8"></a><!-- doxytag: member="gil_concept.hpp::axis_value" ref="ga8" args="(const point2&lt; T &gt; &amp;p)" -->
template&lt;std::size_t K, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>boost::gil::axis_value</b> (const point2&lt; T &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga9"></a><!-- doxytag: member="gil_concept.hpp::axis_value" ref="ga9" args="(point2&lt; T &gt; &amp;p)" -->
template&lt;std::size_t K, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>boost::gil::axis_value</b> (point2&lt; T &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga0"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="ga0" args="(detail::homogeneous_color_base&lt; E, L, N &gt; &amp;p)" -->
template&lt;int K, typename E, typename L, int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">add_reference&lt; E &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0114.html#ga0">boost::gil::at_c</a> (detail::homogeneous_color_base&lt; E, L, N &gt; &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides mutable access to the K-th element, in physical order. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga1"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="ga1" args="(const detail::homogeneous_color_base&lt; E, L, N &gt; &amp;p)" -->
template&lt;int K, typename E, typename L, int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">add_reference&lt; typename add_const &lt;<br>
 E &gt;::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0114.html#ga1">boost::gil::at_c</a> (const detail::homogeneous_color_base&lt; E, L, N &gt; &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides constant access to the K-th element, in physical order. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a90"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="a90" args="(packed_pixel&lt; P, C, L &gt; &amp;p)" -->
template&lt;int K, typename P, typename C, typename L&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">kth_element_reference_type&lt;<br>
 packed_pixel&lt; P, C, L &gt;,<br>
 K &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>boost::gil::at_c</b> (packed_pixel&lt; P, C, L &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a91"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="a91" args="(const packed_pixel&lt; P, C, L &gt; &amp;p)" -->
template&lt;int K, typename P, typename C, typename L&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">kth_element_const_reference_type&lt;<br>
 packed_pixel&lt; P, C, L &gt;,<br>
 K &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>boost::gil::at_c</b> (const packed_pixel&lt; P, C, L &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a92"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="a92" args="(const bit_aligned_pixel_reference&lt; C, L, M &gt; &amp;p)" -->
template&lt;int K, typename C, typename L, bool M&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">kth_element_reference_type&lt;<br>
 bit_aligned_pixel_reference&lt;<br>
 C, L, M &gt;, K &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>boost::gil::at_c</b> (const bit_aligned_pixel_reference&lt; C, L, M &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga0"></a><!-- doxytag: member="gil_concept.hpp::semantic_at_c" ref="ga0" args="(ColorBase &amp;p)" -->
template&lt;int K, typename ColorBase&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">disable_if&lt; is_const &lt; ColorBase &gt;,<br>
 typename kth_semantic_element_reference_type&lt;<br>
 ColorBase, K &gt;::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0109.html#ga0">boost::gil::semantic_at_c</a> (ColorBase &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A mutable accessor to the K-th semantic element of a color base. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga1"></a><!-- doxytag: member="gil_concept.hpp::semantic_at_c" ref="ga1" args="(const ColorBase &amp;p)" -->
template&lt;int K, typename ColorBase&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">kth_semantic_element_const_reference_type&lt;<br>
 ColorBase, K &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0109.html#ga1">boost::gil::semantic_at_c</a> (const ColorBase &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constant accessor to the K-th semantic element of a color base. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a31"></a><!-- doxytag: member="gil_concept.hpp::initialize_it" ref="a31" args="(T &amp;x)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>boost::gil::detail::initialize_it</b> (T &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a93"></a><!-- doxytag: member="gil_concept.hpp::gil_function_requires" ref="a93" args="()" -->
template&lt;typename C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>boost::gil::gil_function_requires</b> ()</td></tr>

</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Nov 8 21:53:18 2007 for Generic Image Library   by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
