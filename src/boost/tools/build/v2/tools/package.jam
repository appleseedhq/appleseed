# Copyright (c) 2005 Vladimir Prus.
# Copyright 2006 Rene Rivera.
#
# Use, modification and distribution is subject to the Boost Software
# License Version 1.0. (See accompanying file LICENSE_1_0.txt or
# http://www.boost.org/LICENSE_1_0.txt)

# Provides mechanism for installing whole packages into a specific directory
# structure. This is opposed to the 'install' rule, that installs a number of
# targets to a single directory, and does not care about directory structure at
# all.

# Example usage:
#
#   package.install boost : <properties>
#                         : <binaries>
#                         : <libraries>
#                         : <headers>
#                         ;
#
# This will install binaries, libraries and headers to the 'proper' location,
# given by command line options --prefix, --exec-prefix, --bindir, --libdir and
# --includedir.
#
# The rule is just a convenient wrapper, avoiding the need to define several
# 'install' targets.
#
# The only install-related feature is <install-source-root>. It will apply to
# headers only and if present, paths of headers relatively to source root will
# be retained after installing. If it is not specified, then "." is assumed, so
# relative paths in headers are always preserved.

import "class" : new ;
import option ;
import project ;
import property ;
import stage ;
import targets ;


rule install ( name : requirements * : binaries * : libraries * : headers * )
{
    # If <install-source-root> is not specified, all headers are installed to
    # prefix/include, no matter what their relative path is. Sometimes that is
    # what is needed.
    local install-source-root = [ property.select <install-source-root> :
        $(requirements) ] ;
    install-source-root = $(install-source-root:G=) ;
    requirements = [ property.change $(requirements) : <install-source-root> ] ;

    local install-header-subdir = [ property.select <install-header-subdir> :
        $(requirements) ] ;
    install-header-subdir = /$(install-header-subdir:G=) ;
    install-header-subdir ?= "" ;
    requirements = [ property.change $(requirements) : <install-header-subdir> ]
        ;

    # First, figure out all locations. Use the default if no prefix option
    # given.
    local prefix = [ option.get prefix : [ property.select
        <install-default-prefix> : $(requirements) ] ] ;
    prefix = $(prefix:G=) ;
    requirements = [ property.change $(requirements) : <install-default-prefix>
        ] ;
    # Or some likely defaults if neither is given.
    if ! $(prefix)
    {
        if [ modules.peek : NT ] { prefix = C:\\$(name) ; }
        else if [ modules.peek : UNIX ] { prefix = /usr/local ; }
    }

    # Architecture dependent files.
    local exec-locate = [ option.get exec-prefix : $(prefix) ] ;

    # Binaries.
    local bin-locate = [ option.get bindir : $(prefix)/bin ] ;

    # Object code libraries.
    local lib-locate = [ option.get libdir : $(prefix)/lib ] ;

    # Source header files.
    local include-locate = [ option.get includedir : $(prefix)/include ] ;

    stage.install $(name)-bin : $(binaries) : $(requirements)
        <location>$(bin-locate) ;
    stage.install $(name)-lib : $(binaries) $(libraries) : $(requirements)
        <location>$(lib-locate) <install-dependencies>on <install-type>LIB ;
    stage.install $(name)-headers : $(headers) : $(requirements)
        <location>$(include-locate)$(install-header-subdir)
        <install-source-root>$(install-source-root) ;
    alias $(name) : $(name)-bin $(name)-lib $(name)-headers ;

    local c = [ project.current ] ;
    local project-module = [ $(c).project-module ] ;
    module $(project-module)
    {
        explicit $(1)-bin $(1)-lib $(1)-headers $(1) ;
    }
}
