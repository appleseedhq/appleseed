<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template variant</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../variant/reference.html#header.boost.variant.variant_hpp" title="Header &lt;boost/variant/variant.hpp&gt;">
<link rel="prev" href="../BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT.html" title="Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT">
<link rel="next" href="swap_id2726109.html" title="Function template swap">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../variant/reference.html#header.boost.variant.variant_hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="swap_id2726109.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.variant"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template variant</span></h2>
<p>boost::variant &#8212; Safe, generic, stack-based discriminated union container.</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../variant/reference.html#header.boost.variant.variant_hpp" title="Header &lt;boost/variant/variant.hpp&gt;">boost/variant/variant.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T1, <span class="bold"><strong>typename</strong></span> T2 = <span class="emphasis"><em>unspecified</em></span>, ..., 
         <span class="bold"><strong>typename</strong></span> TN = <span class="emphasis"><em>unspecified</em></span>&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="variant.html" title="Class template variant">variant</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span> <a name="boost.variant.types"></a>types;

  <span class="emphasis"><em>// <a class="link" href="variant.html#boost.variantconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="variant.html#id2896386-bb">variant</a>();
  <a class="link" href="variant.html#id2896030-bb">variant</a>(<span class="bold"><strong>const</strong></span> variant &amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <a class="link" href="variant.html#id2930997-bb">variant</a>(T &amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <a class="link" href="variant.html#id2960967-bb">variant</a>(<span class="bold"><strong>const</strong></span> T &amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U1, <span class="bold"><strong>typename</strong></span> U2, ..., <span class="bold"><strong>typename</strong></span> UN&gt; 
    <a class="link" href="variant.html#id2303485-bb">variant</a>(variant&lt;U1, U2, ..., UN&gt; &amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U1, <span class="bold"><strong>typename</strong></span> U2, ..., <span class="bold"><strong>typename</strong></span> UN&gt; 
    <a class="link" href="variant.html#id2928665-bb">variant</a>(<span class="bold"><strong>const</strong></span> variant&lt;U1, U2, ..., UN&gt; &amp;);
  <a class="link" href="variant.html#id2746671-bb">~variant</a>();

  <span class="emphasis"><em>// <a class="link" href="variant.html#id2688363-bb">modifiers</a></em></span>
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="variant.html#id2958694-bb">swap</a>(variant &amp;);
  <span class="type">variant &amp;</span> <a class="link" href="variant.html#id1355166-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="bold"><strong>const</strong></span> variant &amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type">variant &amp;</span> <a class="link" href="variant.html#id2927332-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="bold"><strong>const</strong></span> T &amp;);

  <span class="emphasis"><em>// <a class="link" href="variant.html#id1249071-bb">queries</a></em></span>
  <span class="type"><span class="bold"><strong>int</strong></span></span> <a class="link" href="variant.html#id1254444-bb">which</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="variant.html#id2328864-bb">empty</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>const</strong></span> std::type_info &amp;</span> <a class="link" href="variant.html#id2897945-bb">type</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="variant.html#id2683538-bb">relational</a></em></span>
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="variant.html#id1276103-bb"><span class="bold"><strong>operator</strong></span>==</a>(<span class="bold"><strong>const</strong></span> variant &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="variant.html#id2329045-bb"><span class="bold"><strong>operator</strong></span>==</a>(<span class="bold"><strong>const</strong></span> U &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="variant.html#id2372149-bb"><span class="bold"><strong>operator</strong></span>&lt;</a>(<span class="bold"><strong>const</strong></span> variant &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="variant.html#id2374516-bb"><span class="bold"><strong>operator</strong></span>&lt;</a>(<span class="bold"><strong>const</strong></span> U &amp;) <span class="bold"><strong>const</strong></span>;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id4006957"></a><h2>Description</h2>
<p>The <code class="computeroutput">variant</code> class template (inspired by Andrei
        Alexandrescu's class of the same name
        [<a class="link" href="../variant/refs.html#variant.refs.ale01a">Ale01A</a>]) is an efficient,
        <a class="link" href="../variant/tutorial.html#variant.tutorial.recursive" title="Recursive variant types">recursive-capable</a>,
        bounded discriminated union value type capable of containing any value
        type (either POD or non-POD). It supports construction from any type
        convertible to one of its bounded types or from a source
        <code class="computeroutput">variant</code> whose bounded types are each convertible to one
        of the destination <code class="computeroutput">variant</code>'s bounded types. As well,
        through <code class="computeroutput"><a class="link" href="apply_visitor.html" title="Function apply_visitor">apply_visitor</a></code>,
        <code class="computeroutput">variant</code> supports compile-time checked, type-safe
        visitation; and through <code class="computeroutput"><a class="link" href="get_id2747710.html" title="Function get">get</a></code>,
        <code class="computeroutput">variant</code> supports run-time checked, type-safe value
        retrieval.</p>
<p><span class="bold"><strong>Notes</strong></span>:</p>
<div class="itemizedlist"><ul type="disc">
<li>The bounded types of the <code class="computeroutput">variant</code> are exposed
            via the nested typedef <code class="computeroutput">types</code>, which is an
            <a href="../../../libs/mpl/index.html" target="_top">MPL</a>-compatible Sequence containing the
            set of types that must be handled by any
            <a class="link" href="../variant/reference.html#variant.concepts.static-visitor" title="StaticVisitor">visitor</a> to
            the <code class="computeroutput">variant</code>.</li>
<li>All members of <code class="computeroutput">variant</code> satisfy at least the
            basic guarantee of exception-safety. That is, all operations on
            a <code class="computeroutput">variant</code> remain defined even after previous
            operations have failed.</li>
<li>Each type specified as a template argument to
            <code class="computeroutput">variant</code> must meet the requirements of the
            <span class="emphasis"><em><a class="link" href="../variant/reference.html#variant.concepts.bounded-type" title="BoundedType">BoundedType</a></em></span>
            concept.</li>
<li>Each type specified as a template argument to
            <code class="computeroutput">variant</code> must be distinct after removal of qualifiers.
            Thus, for instance, both <code class="computeroutput">variant&lt;int, int&gt;</code> and
            <code class="computeroutput">variant&lt;int, const int&gt;</code> have undefined
            behavior.</li>
<li>Conforming implementations of <code class="computeroutput">variant</code> must
            allow at least ten types as template arguments. The exact number
            of allowed arguments is exposed by the preprocessor macro
            <code class="computeroutput"><a class="link" href="../BOOST_VARIANT_LIMIT_TYPES.html" title="Macro BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</a></code>.
            (See <code class="computeroutput"><a class="link" href="make_variant_over.html" title="Class template make_variant_over">make_variant_over</a></code> for a
            means to specify the bounded types of a <code class="computeroutput">variant</code> by
            the elements of an <a href="../../../libs/mpl/index.html" target="_top">MPL</a> or compatible
            Sequence, thus overcoming this limitation.)</li>
</ul></div>
<div class="refsect2" lang="en">
<a name="id4007201"></a><h3>
<a name="boost.variantconstruct-copy-destruct"></a><code class="computeroutput">variant</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id2896386-bb"></a>variant();</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td>The first bounded type of the <code class="computeroutput">variant</code> (i.e.,
            <code class="computeroutput">T1</code>) must fulfill the requirements of the
            <span class="emphasis"><em>DefaultConstructible</em></span> [20.1.4]
            concept.</td>
</tr>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td>Content of <code class="computeroutput">*this</code> is the default value of the
            first bounded type (i.e, <code class="computeroutput">T1</code>).</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>May fail with any exceptions arising from the default
            constructor of <code class="computeroutput">T1</code>.</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id2896030-bb"></a>variant(<span class="bold"><strong>const</strong></span> variant &amp; other);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td>Content of <code class="computeroutput">*this</code> is a copy of the content of
            <code class="computeroutput">other</code>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>May fail with any exceptions arising from the
            copy constructor of <code class="computeroutput">other</code>'s contained type.</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <a name="id2930997-bb"></a>variant(T &amp; operand);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td>
<code class="computeroutput">T</code> must be unambiguously convertible to one of
            the bounded types (i.e., <code class="computeroutput">T1</code>, <code class="computeroutput">T2</code>,
            etc.).</td>
</tr>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td>Content of <code class="computeroutput">*this</code> is the best conversion of
            <code class="computeroutput">operand</code> to one of the bounded types, as determined
            by standard overload resolution rules.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>May fail with any exceptions arising from the conversion of
            <code class="computeroutput">operand</code> to one of the bounded types.</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <a name="id2960967-bb"></a>variant(<span class="bold"><strong>const</strong></span> T &amp; operand);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td>Same semantics as previous constructor, but allows
            construction from temporaries.</td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U1, <span class="bold"><strong>typename</strong></span> U2, ..., <span class="bold"><strong>typename</strong></span> UN&gt; 
  <a name="id2303485-bb"></a>variant(variant&lt;U1, U2, ..., UN&gt; &amp; operand);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td>
<span class="emphasis"><em>Every</em></span> one of <code class="computeroutput">U1</code>,
            <code class="computeroutput">U2</code>, ..., <code class="computeroutput">UN</code> must have an unambiguous
            conversion to one of the bounded types (i.e., <code class="computeroutput">T1</code>,
            <code class="computeroutput">T2</code>, ..., <code class="computeroutput">TN</code>).</td>
</tr>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td>If <code class="computeroutput">variant&lt;U1, U2, ..., UN&gt;</code> is itself
            one of the bounded types, then content of <code class="computeroutput">*this</code> is a
            copy of <code class="computeroutput">operand</code>. Otherwise, content of
            <code class="computeroutput">*this</code> is the best conversion of the content of
            <code class="computeroutput">operand</code> to one of the bounded types, as determined
            by standard overload resolution rules.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>If <code class="computeroutput">variant&lt;U1, U2, ..., UN&gt;</code> is itself
          one of the bounded types, then may fail with any exceptions arising
          from the copy constructor of
          <code class="computeroutput">variant&lt;U1, U2, ..., UN&gt;</code>. Otherwise, may fail
          with any exceptions arising from the conversion of the content of
          <code class="computeroutput">operand</code> to one of the bounded types.</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U1, <span class="bold"><strong>typename</strong></span> U2, ..., <span class="bold"><strong>typename</strong></span> UN&gt; 
  <a name="id2928665-bb"></a>variant(<span class="bold"><strong>const</strong></span> variant&lt;U1, U2, ..., UN&gt; &amp; operand);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td>Same semantics as previous constructor, but allows
            construction from temporaries.</td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id2746671-bb"></a>~variant();</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td>Destroys the content of <code class="computeroutput">*this</code>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>Will not throw.</td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id4007740"></a><h3>
<a name="id2688363-bb"></a><code class="computeroutput">variant</code> modifiers</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2958694-bb"></a>swap(variant &amp; other);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td>Every bounded type must fulfill the requirements of the
              <a class="link" href="../Assignable.html" title="Concept Assignable">Assignable</a>
              concept.</td>
</tr>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td>Interchanges the content of <code class="computeroutput">*this</code> and
              <code class="computeroutput">other</code>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>If the contained type of <code class="computeroutput">other</code> is the same as
              the contained type of <code class="computeroutput">*this</code>, then may fail with any
              exceptions arising from the <code class="computeroutput">swap</code> of the contents of
              <code class="computeroutput">*this</code> and <code class="computeroutput">other</code>. Otherwise, may fail
              with any exceptions arising from either of the copy constructors
              of the contained types. Also, in the event of insufficient
              memory, may fail with <code class="computeroutput">std::bad_alloc</code>
              (<a class="link" href="../variant/design.html#variant.design.never-empty.problem" title="The Implementation Problem">why?</a>).</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">variant &amp;</span> <a name="id1355166-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="bold"><strong>const</strong></span> variant &amp; rhs);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td>Every bounded type must fulfill the requirements of the
              <a class="link" href="../Assignable.html" title="Concept Assignable">Assignable</a>
              concept.</td>
</tr>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td>If the contained type of <code class="computeroutput">rhs</code> is the same as
              the contained type of <code class="computeroutput">*this</code>, then assigns the
              content of <code class="computeroutput">rhs</code> into the content of
              <code class="computeroutput">*this</code>. Otherwise, makes the content of
              <code class="computeroutput">*this</code> a copy of the content of <code class="computeroutput">rhs</code>,
              destroying the previous content of <code class="computeroutput">*this</code>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>If the contained type of <code class="computeroutput">rhs</code> is the same as
              the contained type of <code class="computeroutput">*this</code>, then may fail with any
              exceptions arising from the assignment of the content of
              <code class="computeroutput">rhs</code> into the content <code class="computeroutput">*this</code>. Otherwise,
              may fail with any exceptions arising from the copy constructor
              of the contained type of <code class="computeroutput">rhs</code>. Also, in the event of
              insufficient memory, may fail with <code class="computeroutput">std::bad_alloc</code>
              (<a class="link" href="../variant/design.html#variant.design.never-empty.problem" title="The Implementation Problem">why?</a>).</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type">variant &amp;</span> <a name="id2927332-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="bold"><strong>const</strong></span> T &amp; rhs);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><div class="itemizedlist"><ul type="disc">
<li>
<code class="computeroutput">T</code> must be unambiguously convertible to
                one of the bounded types (i.e., <code class="computeroutput">T1</code>,
                <code class="computeroutput">T2</code>, etc.).</li>
<li>Every bounded type must fulfill the requirements of the
                <a class="link" href="../Assignable.html" title="Concept Assignable">Assignable</a>
                concept.</li>
</ul></div></td>
</tr>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td>If the contained type of <code class="computeroutput">*this</code> is
              <code class="computeroutput">T</code>, then assigns <code class="computeroutput">rhs</code> into the content
              of <code class="computeroutput">*this</code>. Otherwise, makes the content of
              <code class="computeroutput">*this</code> the best conversion of <code class="computeroutput">rhs</code> to
              one of the bounded types, as determined by standard overload
              resolution rules, destroying the previous content of
              <code class="computeroutput">*this</code>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>If the contained type of <code class="computeroutput">*this</code> is
              <code class="computeroutput">T</code>, then may fail with any exceptions arising from
              the assignment of <code class="computeroutput">rhs</code> into the content
              <code class="computeroutput">*this</code>. Otherwise, may fail with any exceptions
              arising from the conversion of <code class="computeroutput">rhs</code> to one of the
              bounded types. Also, in the event of insufficient memory, may
              fail with <code class="computeroutput">std::bad_alloc</code>
              (<a class="link" href="../variant/design.html#variant.design.never-empty.problem" title="The Implementation Problem">why?</a>).</td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id4008217"></a><h3>
<a name="id1249071-bb"></a><code class="computeroutput">variant</code> queries</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>int</strong></span></span> <a name="id1254444-bb"></a>which() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>The zero-based index into the set of bounded types
              of the contained type of <code class="computeroutput">*this</code>. (For instance, if
              called on a <code class="computeroutput">variant&lt;int, std::string&gt;</code> object
              containing a <code class="computeroutput">std::string</code>, <code class="computeroutput">which()</code>
              would return <code class="computeroutput">1</code>.)</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>Will not throw.</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id2328864-bb"></a>empty() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<code class="computeroutput">false</code>: <code class="computeroutput">variant</code> always contains
              exactly one of its bounded types. (See
              <a class="xref" href="../variant/design.html#variant.design.never-empty" title='"Never-Empty" Guarantee'>the section called &#8220;"Never-Empty" Guarantee&#8221;</a>
              for more information.)</td>
</tr>
<tr>
<td><p><span class="term">Rationale:</span></p></td>
<td>Facilitates generic compatibility with
              <a class="link" href="any.html" title="Class any">boost::any</a>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>Will not throw.</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>const</strong></span> std::type_info &amp;</span> <a name="id2897945-bb"></a>type() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<code class="computeroutput">typeid(x)</code>, where <code class="computeroutput">x</code> is the the
              content of <code class="computeroutput">*this</code>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>Will not throw.</td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id4008448"></a><h3>
<a name="id2683538-bb"></a><code class="computeroutput">variant</code> relational</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id2683541-bb"></a><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id1276103-bb"></a><span class="bold"><strong>operator</strong></span>==(<span class="bold"><strong>const</strong></span> variant &amp; rhs) <span class="bold"><strong>const</strong></span>;
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2329045-bb"></a><span class="bold"><strong>operator</strong></span>==(<span class="bold"><strong>const</strong></span> U &amp;) <span class="bold"><strong>const</strong></span>;</pre>Equality comparison.<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>The overload returning <code class="computeroutput">void</code> exists only to
              prohibit implicit conversion of the operator's right-hand side
              to <code class="computeroutput">variant</code>; thus, its use will (purposefully)
              result in a compile-time error.</td>
</tr>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td>Every bounded type of the <code class="computeroutput">variant</code> must
              fulfill the requirements of the
              <a class="link" href="../EqualityComparable.html" title="Concept EqualityComparable">EqualityComparable</a>
              concept.</td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<code class="computeroutput">true</code> iff <code class="computeroutput">which() == rhs.which()</code>
              <span class="emphasis"><em>and</em></span>
              <code class="computeroutput">content_this == content_rhs</code>, where
              <code class="computeroutput">content_this</code> is the content of <code class="computeroutput">*this</code>
              and <code class="computeroutput">content_rhs</code> is the content of
              <code class="computeroutput">rhs</code>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>If <code class="computeroutput">which() == rhs.which()</code> then may fail with
              any exceptions arising from <code class="computeroutput">operator==(T,T)</code>, where
              <code class="computeroutput">T</code> is the contained type of
              <code class="computeroutput">*this</code>.</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id2746795-bb"></a><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id2372149-bb"></a><span class="bold"><strong>operator</strong></span>&lt;(<span class="bold"><strong>const</strong></span> variant &amp; rhs) <span class="bold"><strong>const</strong></span>;
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2374516-bb"></a><span class="bold"><strong>operator</strong></span>&lt;(<span class="bold"><strong>const</strong></span> U &amp;) <span class="bold"><strong>const</strong></span>;</pre>LessThan comparison.<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>The overload returning <code class="computeroutput">void</code> exists only to
              prohibit implicit conversion of the operator's right-hand side
              to <code class="computeroutput">variant</code>; thus, its use will (purposefully)
              result in a compile-time error.</td>
</tr>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td>Every bounded type of the <code class="computeroutput">variant</code> must
              fulfill the requirements of the
              <a class="link" href="../LessThanComparable.html" title="Concept LessThanComparable">LessThanComparable</a>
              concept.</td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>If <code class="computeroutput">which() == rhs.which()</code> then:
              <code class="computeroutput">content_this &lt; content_rhs</code>, where
              <code class="computeroutput">content_this</code> is the content of <code class="computeroutput">*this</code>
              and <code class="computeroutput">content_rhs</code> is the content of <code class="computeroutput">rhs</code>.
              Otherwise: <code class="computeroutput">which() &lt; rhs.which()</code>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>If <code class="computeroutput">which() == rhs.which()</code> then may fail with
              any exceptions arising from <code class="computeroutput">operator&lt;(T,T)</code>,
              where <code class="computeroutput">T</code> is the contained type of
              <code class="computeroutput">*this</code>.</td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2002, 2003 Eric Friedman, Itay Maman<p>Permission to copy, use, sell and distribute this software
    is granted provided this copyright notice appears in all copies.
    Permission to modify the code and to distribute modified code is
    granted provided this copyright notice appears in all copies, and
    a notice that the code was modified is included with the copyright
    notice.</p>
<p> This software is provided "as is" without express or
    implied warranty, and with no claim as to its suitability for any
    purpose.</p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../variant/reference.html#header.boost.variant.variant_hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="swap_id2726109.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
