<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template unordered_set</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../unordered/reference.html#header.boost.unordered_set_hpp" title="Header &lt;boost/unordered_set.hpp&gt;">
<link rel="prev" href="../unordered/reference.html" title="Reference">
<link rel="next" href="unordered_multiset.html" title="Class template unordered_multiset">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../unordered/reference.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered/reference.html#header.boost.unordered_set_hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="unordered_multiset.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.unordered_set"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template unordered_set</span></h2>
<p>boost::unordered_set &#8212; 
            An unordered associative container that stores unique values.
          </p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../unordered/reference.html#header.boost.unordered_set_hpp" title="Header &lt;boost/unordered_set.hpp&gt;">boost/unordered_set.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash = <span class="type">boost::hash&lt;Value&gt;</span>, 
         <span class="bold"><strong>typename</strong></span> Pred = <span class="type">std::equal_to&lt;Value&gt;</span>, 
         <span class="bold"><strong>typename</strong></span> Alloc = <span class="type">std::allocator&lt;Value&gt;</span> &gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="unordered_set.html" title="Class template unordered_set">unordered_set</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// <a class="link" href="unordered_set.html#boost.unordered_settypes">types</a></em></span>
  <span class="bold"><strong>typedef</strong></span> Value                                    <a name="boost.unordered_set.key_type"></a>key_type;            
  <span class="bold"><strong>typedef</strong></span> Value                                    <a name="boost.unordered_set.value_type"></a>value_type;          
  <span class="bold"><strong>typedef</strong></span> Hash                                     <a name="boost.unordered_set.hasher"></a>hasher;              
  <span class="bold"><strong>typedef</strong></span> Pred                                     <a name="boost.unordered_set.key_equal"></a>key_equal;           
  <span class="bold"><strong>typedef</strong></span> Alloc                                    <a name="boost.unordered_set.allocator_type"></a>allocator_type;      
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::pointer         <a name="boost.unordered_set.pointer"></a>pointer;             
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::const_pointer   <a name="boost.unordered_set.const_pointer"></a>const_pointer;       
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::reference       <a name="boost.unordered_set.reference"></a>reference;             <span class="emphasis"><em>// lvalue of <span class="type">value_type</span>.</em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::const_reference <a name="boost.unordered_set.const_reference"></a>const_reference;       <span class="emphasis"><em>// const lvalue of <span class="type">value_type</span>.</em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_set.html#boost.unordered_set.size_type">size_type</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_set.html#boost.unordered_set.difference_type">difference_type</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_set.html#boost.unordered_set.iterator">iterator</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_set.html#boost.unordered_set.const_iterator">const_iterator</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_set.html#boost.unordered_set.local_iterator">local_iterator</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_set.html#boost.unordered_set.const_local_iterator">const_local_iterator</a>;

  <span class="emphasis"><em>// <a class="link" href="unordered_set.html#boost.unordered_setconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <span class="bold"><strong>explicit</strong></span> <a class="link" href="unordered_set.html#id2724511-bb">unordered_set</a>(size_type = <span class="emphasis"><em>implementation-defined</em></span>, 
                         hasher <span class="bold"><strong>const</strong></span>&amp; = hasher(), 
                         key_equal <span class="bold"><strong>const</strong></span>&amp; = key_equal(), 
                         allocator_type <span class="bold"><strong>const</strong></span>&amp; = allocator_type());
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; 
    <a class="link" href="unordered_set.html#id2724592-bb">unordered_set</a>(InputIterator, InputIterator, 
                  size_type = implementation-defined, 
                  hasher <span class="bold"><strong>const</strong></span>&amp; = hasher(), key_equal <span class="bold"><strong>const</strong></span>&amp; = key_equal(), 
                  allocator_type <span class="bold"><strong>const</strong></span>&amp; = allocator_type());
  <a class="link" href="unordered_set.html#id2724691-bb">unordered_set</a>(unordered_set <span class="bold"><strong>const</strong></span>&amp;);
  <span class="bold"><strong>explicit</strong></span> <a class="link" href="unordered_set.html#id2724712-bb">unordered_set</a>(Allocator <span class="bold"><strong>const</strong></span>&amp;);
  <a class="link" href="unordered_set.html#id2724740-bb">unordered_set</a>(unordered_set <span class="bold"><strong>const</strong></span>&amp;, Allocator <span class="bold"><strong>const</strong></span>&amp;);
  <a class="link" href="unordered_set.html#id2724780-bb">~unordered_set</a>();
  <span class="type">unordered_set&amp;</span> <a class="link" href="unordered_set.html#id2724784-bb"><span class="bold"><strong>operator</strong></span>=</a>(unordered_set <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">allocator_type</span> <a class="link" href="unordered_set.html#id2724810-bb">get_allocator</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_set.html#id2724822-bb">size and capacity</a></em></span>
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="unordered_set.html#id2724827-bb">empty</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_set.html#id2724849-bb">size</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_set.html#id2724876-bb">max_size</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_set.html#id2724898-bb">iterators</a></em></span>
  <span class="type">iterator</span> <a class="link" href="unordered_set.html#id2724907-bb">begin</a>();
  <span class="type">const_iterator</span> <a class="link" href="unordered_set.html#id2724912-bb">begin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a class="link" href="unordered_set.html#id2724931-bb">end</a>();
  <span class="type">const_iterator</span> <a class="link" href="unordered_set.html#id2724939-bb">end</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a class="link" href="unordered_set.html#id2724955-bb">cbegin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a class="link" href="unordered_set.html#id2724973-bb">cend</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_set.html#id2724991-bb">modifiers</a></em></span>
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <span class="type">std::pair&lt;iterator, <span class="bold"><strong>bool</strong></span>&gt;</span> <a class="link" href="unordered_set.html#id2724996-bb">emplace</a>(Args&amp;&amp;...);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <span class="type">iterator</span> <a class="link" href="unordered_set.html#id2725091-bb">emplace_hint</a>(const_iterator, Args&amp;&amp;...);
  <span class="type">std::pair&lt;iterator, <span class="bold"><strong>bool</strong></span>&gt;</span> <a class="link" href="unordered_set.html#id2725202-bb">insert</a>(value_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">iterator</span> <a class="link" href="unordered_set.html#id2725274-bb">insert</a>(const_iterator, value_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_set.html#id2725361-bb">insert</a>(InputIterator, InputIterator);
  <span class="type">iterator</span> <a class="link" href="unordered_set.html#id2725439-bb">erase</a>(const_iterator);
  <span class="type">size_type</span> <a class="link" href="unordered_set.html#id2725504-bb">erase</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">iterator</span> <a class="link" href="unordered_set.html#id2725560-bb">erase</a>(const_iterator, const_iterator);
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_set.html#id2725639-bb">clear</a>();
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_set.html#id2725676-bb">swap</a>(unordered_set&amp;);

  <span class="emphasis"><em>// <a class="link" href="unordered_set.html#id1217207-bb">observers</a></em></span>
  <span class="type">hasher</span> <a class="link" href="unordered_set.html#id1217212-bb">hash_function</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">key_equal</span> <a class="link" href="unordered_set.html#id2678689-bb">key_eq</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_set.html#id2678707-bb">lookup</a></em></span>
  <span class="type">iterator</span> <a class="link" href="unordered_set.html#id2678716-bb">find</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">iterator</span> <a class="link" href="unordered_set.html#id2678734-bb">find</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_set.html#id2678772-bb">count</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">std::pair&lt;iterator, iterator&gt;</span> <a class="link" href="unordered_set.html#id2678810-bb">equal_range</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);
  <span class="type">std::pair&lt;const_iterator, const_iterator&gt;</span> <a class="link" href="unordered_set.html#id2678828-bb">equal_range</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="unordered_set.html#id2678880-bb">bucket interface</a></em></span>
  <span class="type">size_type</span> <a class="link" href="unordered_set.html#id2678884-bb">bucket_count</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_set.html#id2678904-bb">max_bucket_count</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_set.html#id2678924-bb">bucket_size</a>(size_type) <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="unordered_set.html#id2678970-bb">bucket</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">local_iterator</span> <a class="link" href="unordered_set.html#id2679020-bb">begin</a>(size_type);
  <span class="type">const_local_iterator</span> <a class="link" href="unordered_set.html#id2679038-bb">begin</a>(size_type) <span class="bold"><strong>const</strong></span>;
  <span class="type">local_iterator</span> <a class="link" href="unordered_set.html#id2679091-bb">end</a>(size_type);
  <span class="type">const_local_iterator</span> <a class="link" href="unordered_set.html#id2679109-bb">end</a>(size_type) <span class="bold"><strong>const</strong></span>;
  <span class="type">const_local_iterator</span> <a class="link" href="unordered_set.html#id2679158-bb">cbegin</a>(size_type) <span class="bold"><strong>const</strong></span>;
  <span class="type">const_local_iterator</span> <a class="link" href="unordered_set.html#id2679207-bb">cend</a>(size_type);

  <span class="emphasis"><em>// <a class="link" href="unordered_set.html#id2679255-bb">hash policy</a></em></span>
  <span class="type"><span class="bold"><strong>float</strong></span></span> <a class="link" href="unordered_set.html#id2679260-bb">load_factor</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>float</strong></span></span> <a class="link" href="unordered_set.html#id2679280-bb">max_load_factor</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_set.html#id2679300-bb">max_load_factor</a>(<span class="bold"><strong>float</strong></span>);
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_set.html#id2679332-bb">rehash</a>(size_type);
};

<span class="emphasis"><em>// <a class="link" href="unordered_set.html#id2679381-bb">Equality Comparisons</a></em></span>
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="unordered_set.html#boost.operator==_id2679386"><span class="bold"><strong>operator</strong></span>==</a>(unordered_set&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;, 
                  unordered_set&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;);
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="unordered_set.html#boost.operator!=_id2679460"><span class="bold"><strong>operator</strong></span>!=</a>(unordered_set&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;, 
                  unordered_set&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;);

<span class="emphasis"><em>// <a class="link" href="unordered_set.html#id2679534-bb">swap</a></em></span>
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_set.html#boost.swap_id2679539">swap</a>(unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp;, 
            unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp;);</pre></div>
<div class="refsect1" lang="en">
<a name="id3967561"></a><h2>Description</h2>
<p>For the normative reference see chapter 23 of
              <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008-2009/n2691.pdf" target="_top">the working draft of the C++ standard [n2691].</a></p>
<p><span class="bold"><strong>Template Parameters</strong></span>
              </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td><span class="emphasis"><em>Value</em></span></td>
<td>Value must be Assignable and CopyConstructible</td>
</tr>
<tr>
<td><span class="emphasis"><em>Hash</em></span></td>
<td>A unary function object type that acts a hash function for a <code class="computeroutput">Value</code>. It takes a single argument of type <code class="computeroutput">Value</code> and returns a value of type std::size_t.</td>
</tr>
<tr>
<td><span class="emphasis"><em>Pred</em></span></td>
<td>A binary function object that implements an equivalence relation on values of type <code class="computeroutput">Value</code>.
                        A binary function object that induces an equivalence relation on values of type Key.
                        It takes two arguments of type Key and returns a value of type bool.</td>
</tr>
<tr>
<td><span class="emphasis"><em>Alloc</em></span></td>
<td>An allocator whose value type is the same as the container's value type.</td>
</tr>
</tbody>
</table></div>
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
<div class="refsect2" lang="en">
<a name="id3967666"></a><h3>
<a name="boost.unordered_settypes"></a><code class="computeroutput">unordered_set</code> 
        public
       types</h3>
<div class="orderedlist"><ol type="1">
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_set.size_type"></a>size_type;</p>
<p>An unsigned integral type.</p>
<p><span class="type">size_type</span> can represent any non-negative value of <span class="type">difference_type</span>.</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_set.difference_type"></a>difference_type;</p>
<p>A signed integral type.</p>
<p>Is identical to the difference type of <span class="type">iterator</span> and <span class="type">const_iterator</span>.</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_set.iterator"></a>iterator;</p>
<p>A constant iterator whose value type is <span class="type">value_type</span>. </p>
<p>Any iterator category except output iterator.</p>
<p>Convertible to <span class="type">const_iterator</span>.</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_set.const_iterator"></a>const_iterator;</p>
<p>A constant iterator whose value type is <span class="type">value_type</span>. </p>
<p>Any iterator category except output iterator.</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_set.local_iterator"></a>local_iterator;</p>
<p>An iterator with the same value type, difference type and pointer and reference type as <span class="type">iterator</span>.</p>
<p>A local_iterator object can be used to iterate through a single bucket.</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_set.const_local_iterator"></a>const_local_iterator;</p>
<p>A constant iterator with the same value type, difference type and pointer and reference type as <span class="type">const_iterator</span>.</p>
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3967890"></a><h3>
<a name="boost.unordered_setconstruct-copy-destruct"></a><code class="computeroutput">unordered_set</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="bold"><strong>explicit</strong></span> <a name="id2724511-bb"></a>unordered_set(size_type n = <span class="emphasis"><em>implementation-defined</em></span>, 
                       hasher <span class="bold"><strong>const</strong></span>&amp; hf = hasher(), 
                       key_equal <span class="bold"><strong>const</strong></span>&amp; eq = key_equal(), 
                       allocator_type <span class="bold"><strong>const</strong></span>&amp; a = allocator_type());</pre>
<p>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><code class="computeroutput"><a class="link" href="unordered_set.html#id2724849-bb">size</a>() == 0</code></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; 
  <a name="id2724592-bb"></a>unordered_set(InputIterator f, InputIterator l, 
                size_type n = implementation-defined, 
                hasher <span class="bold"><strong>const</strong></span>&amp; hf = hasher(), 
                key_equal <span class="bold"><strong>const</strong></span>&amp; eq = key_equal(), 
                allocator_type <span class="bold"><strong>const</strong></span>&amp; a = allocator_type());</pre>
<p>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.</p>
</li>
<li>
<pre class="literallayout"><a name="id2724691-bb"></a>unordered_set(unordered_set <span class="bold"><strong>const</strong></span>&amp;);</pre>
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>explicit</strong></span> <a name="id2724712-bb"></a>unordered_set(Allocator <span class="bold"><strong>const</strong></span>&amp; a);</pre>
<p>Constructs an empty container, using allocator <code class="computeroutput">a</code>.</p>
</li>
<li>
<pre class="literallayout"><a name="id2724740-bb"></a>unordered_set(unordered_set <span class="bold"><strong>const</strong></span>&amp; x, Allocator <span class="bold"><strong>const</strong></span>&amp; a);</pre>
<p>Constructs an container, copying <code class="computeroutput">x</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code class="computeroutput">a</code>.</p>
</li>
<li><pre class="literallayout"><a name="id2724780-bb"></a>~unordered_set();</pre></li>
</ol></div>
</div>
<pre class="literallayout"><span class="type">unordered_set&amp;</span> <a name="id2724784-bb"></a><span class="bold"><strong>operator</strong></span>=(unordered_set <span class="bold"><strong>const</strong></span>&amp;);</pre>
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
<pre class="literallayout"><span class="type">allocator_type</span> <a name="id2724810-bb"></a>get_allocator() <span class="bold"><strong>const</strong></span>;</pre>
<div class="refsect2" lang="en">
<a name="id3968202"></a><h3>
<a name="id2724822-bb"></a><code class="computeroutput">unordered_set</code> size and capacity</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id2724827-bb"></a>empty() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><code class="computeroutput"><a class="link" href="unordered_set.html#id2724849-bb">size</a>() == 0</code></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id2724849-bb"></a>size() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><code class="computeroutput">std::distance(<a class="link" href="unordered_set.html#id2724903-bb">begin</a>(), <a class="link" href="unordered_set.html#id2724926-bb">end</a>())</code></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id2724876-bb"></a>max_size() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<code class="computeroutput"><a class="link" href="unordered_set.html#id2724849-bb">size</a>()</code> of the largest possible container.
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3968362"></a><h3>
<a name="id2724898-bb"></a><code class="computeroutput">unordered_set</code> iterators</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id2724903-bb"></a><span class="type">iterator</span> <a name="id2724907-bb"></a>begin();
<span class="type">const_iterator</span> <a name="id2724912-bb"></a>begin() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id2724926-bb"></a><span class="type">iterator</span> <a name="id2724931-bb"></a>end();
<span class="type">const_iterator</span> <a name="id2724939-bb"></a>end() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>An iterator which refers to the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2724955-bb"></a>cbegin() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>A constant iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2724973-bb"></a>cend() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>A constant iterator which refers to the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3968545"></a><h3>
<a name="id2724991-bb"></a><code class="computeroutput">unordered_set</code> modifiers</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <span class="type">std::pair&lt;iterator, <span class="bold"><strong>bool</strong></span>&gt;</span> <a name="id2724996-bb"></a>emplace(Args&amp;&amp;... args);</pre>
<p>Inserts an object, constructed with the arguments <code class="computeroutput">args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<p>The bool component of the return type is true if an insert took place.</p>
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
<p>Only available on compilers with support for variadic template arguments and rvalue references.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; 
  <span class="type">iterator</span> <a name="id2725091-bb"></a>emplace_hint(const_iterator hint, Args&amp;&amp;... args);</pre>
<p>Inserts an object, constructed with the arguments <code class="computeroutput">args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
<p>hint is a suggestion to where the element should be inserted.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same value. </p>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
<p>Only available on compilers with support for variadic template arguments and rvalue references.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">std::pair&lt;iterator, <span class="bold"><strong>bool</strong></span>&gt;</span> <a name="id2725202-bb"></a>insert(value_type <span class="bold"><strong>const</strong></span>&amp; obj);</pre>
<p>Inserts obj in the container if and only if there is no element in the container with an equivalent value.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<p>The bool component of the return type is true if an insert took place.</p>
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2725274-bb"></a>insert(const_iterator hint, value_type <span class="bold"><strong>const</strong></span>&amp; obj);</pre>
<p>Inserts obj in the container if and only if there is no element in the container with an equivalent value.</p>
<p>hint is a suggestion to where the element should be inserted.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same value. </p>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2725361-bb"></a>insert(InputIterator first, InputIterator last);</pre>
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent value.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>When inserting a single element, if an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2725439-bb"></a>erase(const_iterator position);</pre>
<p>Erase the element pointed to by <code class="computeroutput">position</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The iterator following <code class="computeroutput">position</code> before the erasure.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p>
<p>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id2725504-bb"></a>erase(key_type <span class="bold"><strong>const</strong></span>&amp; k);</pre>
<p>Erase all elements with key equivalent to <code class="computeroutput">k</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of elements erased.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2725560-bb"></a>erase(const_iterator first, const_iterator last);</pre>
<p>Erases the elements in the range from <code class="computeroutput">first</code> to <code class="computeroutput">last</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The iterator following the erased elements - i.e. <code class="computeroutput">last</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p>
<p>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2725639-bb"></a>clear();</pre>
<p>Erases all elements in the container.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><p><code class="computeroutput"><a class="link" href="unordered_set.html#id2724849-bb">size</a>() == 0</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>Never throws an exception.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2725676-bb"></a>swap(unordered_set&amp;);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code class="computeroutput">key_equal</code> or <code class="computeroutput">hasher</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>For a discussion of the behavior when allocators aren't equal see
                  <a class="link" href="../unordered/rationale.html#unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</a>.</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3969292"></a><h3>
<a name="id1217207-bb"></a><code class="computeroutput">unordered_set</code> observers</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type">hasher</span> <a name="id1217212-bb"></a>hash_function() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>The container's hash function.
              </td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">key_equal</span> <a name="id2678689-bb"></a>key_eq() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>The container's key equality predicate.
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3969379"></a><h3>
<a name="id2678707-bb"></a><code class="computeroutput">unordered_set</code> lookup</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id2678711-bb"></a><span class="type">iterator</span> <a name="id2678716-bb"></a>find(key_type <span class="bold"><strong>const</strong></span>&amp; k);
<span class="type">iterator</span> <a name="id2678734-bb"></a>find(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>An iterator pointing to an element with key equivalent to <code class="computeroutput">k</code>, or <code class="computeroutput">b.end()</code> if no such element exists.</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id2678772-bb"></a>count(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of elements with key equivalent to <code class="computeroutput">k</code>.</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id2678805-bb"></a><span class="type">std::pair&lt;iterator, iterator&gt;</span> <a name="id2678810-bb"></a>equal_range(key_type <span class="bold"><strong>const</strong></span>&amp; k);
<span class="type">std::pair&lt;const_iterator, const_iterator&gt;</span> <a name="id2678828-bb"></a>equal_range(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A range containing all elements with key equivalent to <code class="computeroutput">k</code>.
                  If the container doesn't container any such elements, returns
                  <code class="computeroutput">std::make_pair(b.end(),b.end())</code>.
                  </p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3969590"></a><h3>
<a name="id2678880-bb"></a><code class="computeroutput">unordered_set</code> bucket interface</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id2678884-bb"></a>bucket_count() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of buckets.</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id2678904-bb"></a>max_bucket_count() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>An upper bound on the number of buckets.</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id2678924-bb"></a>bucket_size(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n &lt; <a class="link" href="unordered_set.html#id2678884-bb">bucket_count</a>()</code></p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of elements in bucket <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id2678970-bb"></a>bucket(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The index of the bucket which would contain an element with key <code class="computeroutput">k</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><p>The return value is less than <code class="computeroutput">bucket_count()</code></p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id2679015-bb"></a><span class="type">local_iterator</span> <a name="id2679020-bb"></a>begin(size_type n);
<span class="type">const_local_iterator</span> <a name="id2679038-bb"></a>begin(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A local iterator pointing the first element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id2679086-bb"></a><span class="type">local_iterator</span> <a name="id2679091-bb"></a>end(size_type n);
<span class="type">const_local_iterator</span> <a name="id2679109-bb"></a>end(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A local iterator pointing the 'one past the end' element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">const_local_iterator</span> <a name="id2679158-bb"></a>cbegin(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A constant local iterator pointing the first element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">const_local_iterator</span> <a name="id2679207-bb"></a>cend(size_type n);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3970051"></a><h3>
<a name="id2679255-bb"></a><code class="computeroutput">unordered_set</code> hash policy</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>float</strong></span></span> <a name="id2679260-bb"></a>load_factor() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The average number of elements per bucket.</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>float</strong></span></span> <a name="id2679280-bb"></a>max_load_factor() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Returns the current maximum load factor.</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2679300-bb"></a>max_load_factor(<span class="bold"><strong>float</strong></span> z);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Effects:</span></p></td>
<td><p>Changes the container's maximum load factor, using <code class="computeroutput">z</code> as a hint.</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2679332-bb"></a>rehash(size_type n);</pre>
<p>Changes the number of buckets so that there at least <code class="computeroutput">n</code> buckets, and so that the load factor is less than the maximum load factor.</p>
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.</p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3970238"></a><h3>
<a name="id2679381-bb"></a><code class="computeroutput">unordered_set</code> Equality Comparisons</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="boost.operator==_id2679386"></a><span class="bold"><strong>operator</strong></span>==(unordered_set&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; x, 
                  unordered_set&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; y);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>This is a boost extension.</p>
<p>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.</p>
</td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="boost.operator!=_id2679460"></a><span class="bold"><strong>operator</strong></span>!=(unordered_set&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; x, 
                  unordered_set&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; y);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>This is a boost extension.</p>
<p>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.</p>
</td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3970424"></a><h3>
<a name="id2679534-bb"></a><code class="computeroutput">unordered_set</code> swap</h3>
<div class="orderedlist"><ol type="1"><li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="boost.swap_id2679539"></a>swap(unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp; y);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td><p><code class="computeroutput">x.swap(y)</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code class="computeroutput">Hash</code> or <code class="computeroutput">Pred</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>For a discussion of the behavior when allocators aren't equal see
                  <a class="link" href="../unordered/rationale.html#unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</a>.</p></td>
</tr>
</tbody>
</table></div>
</li></ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright  2003, 2004 Jeremy B. Maitin-Shepard<br>Copyright  2005-2008 Daniel
      James<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../unordered/reference.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered/reference.html#header.boost.unordered_set_hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="unordered_multiset.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
