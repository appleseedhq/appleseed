<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Struct template string_parse_tree</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="../../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../../date_time/doxy.html#header.boost.date_time.string_parse_tree_hpp" title="Header &lt;boost/date_time/string_parse_tree.hpp&gt;">
<link rel="prev" href="parse_match_result.html" title="Struct template parse_match_result">
<link rel="next" href="gather_month_strings.html" title="Function template gather_month_strings">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="parse_match_result.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../date_time/doxy.html#header.boost.date_time.string_parse_tree_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="gather_month_strings.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.date_time.string_parse_tree"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Struct template string_parse_tree</span></h2>
<p>boost::date_time::string_parse_tree &#8212; Recursive data structure to allow efficient parsing of various strings. </p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../../date_time/doxy.html#header.boost.date_time.string_parse_tree_hpp" title="Header &lt;boost/date_time/string_parse_tree.hpp&gt;">boost/date_time/string_parse_tree.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> charT&gt; 
<span class="bold"><strong>struct</strong></span> <a class="link" href="string_parse_tree.html" title="Struct template string_parse_tree">string_parse_tree</a> {
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> std::multimap&lt; charT, <a class="link" href="string_parse_tree.html" title="Struct template string_parse_tree">string_parse_tree</a>&lt; charT &gt; &gt; <a name="boost.date_time.string_parse_tree.ptree_coll"></a>ptree_coll;             
  <span class="bold"><strong>typedef</strong></span> std::multimap&lt; charT, <a class="link" href="string_parse_tree.html" title="Struct template string_parse_tree">string_parse_tree</a> &gt;          <a name="boost.date_time.string_parse_tree.ptree_coll"></a>ptree_coll;             
  <span class="bold"><strong>typedef</strong></span> ptree_coll::value_type                             <a name="boost.date_time.string_parse_tree.value_type"></a>value_type;             
  <span class="bold"><strong>typedef</strong></span> ptree_coll::iterator                               <a name="boost.date_time.string_parse_tree.iterator"></a>iterator;               
  <span class="bold"><strong>typedef</strong></span> ptree_coll::const_iterator                         <a name="boost.date_time.string_parse_tree.const_iterator"></a>const_iterator;         
  <span class="bold"><strong>typedef</strong></span> std::basic_string&lt; charT &gt;                         <a name="boost.date_time.string_parse_tree.string_type"></a>string_type;            
  <span class="bold"><strong>typedef</strong></span> std::vector&lt; std::basic_string&lt; charT &gt; &gt;          <a name="boost.date_time.string_parse_tree.collection_type"></a>collection_type;        
  <span class="bold"><strong>typedef</strong></span> parse_match_result&lt; charT &gt;                        <a name="boost.date_time.string_parse_tree.parse_match_result_type"></a>parse_match_result_type;

  <span class="emphasis"><em>// <a class="link" href="string_parse_tree.html#boost.date_time.string_parse_treeconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="string_parse_tree.html#id1110509-bb">string_parse_tree</a>(collection_type, <span class="bold"><strong>unsigned</strong></span> <span class="bold"><strong>int</strong></span> = 0);
  <a class="link" href="string_parse_tree.html#id1110531-bb">string_parse_tree</a>(<span class="bold"><strong>short</strong></span> = -1);

  <span class="emphasis"><em>// <a class="link" href="string_parse_tree.html#id732718-bb">public member functions</a></em></span>
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="string_parse_tree.html#id732722-bb">insert</a>(<span class="bold"><strong>const</strong></span> string_type &amp;, <span class="bold"><strong>unsigned</strong></span> <span class="bold"><strong>short</strong></span>) ;
  <span class="type"><span class="bold"><strong>short</strong></span></span> <a class="link" href="string_parse_tree.html#id725907-bb">match</a>(std::istreambuf_iterator&lt; charT &gt; &amp;, 
              std::istreambuf_iterator&lt; charT &gt; &amp;, parse_match_result_type &amp;, 
              <span class="bold"><strong>unsigned</strong></span> <span class="bold"><strong>int</strong></span> &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">parse_match_result_type</span> 
  <a class="link" href="string_parse_tree.html#id647172-bb">match</a>(std::istreambuf_iterator&lt; charT &gt; &amp;, 
        std::istreambuf_iterator&lt; charT &gt; &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="string_parse_tree.html#id653964-bb">printme</a>(std::ostream &amp;, <span class="bold"><strong>int</strong></span> &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="string_parse_tree.html#id612451-bb">print</a>(std::ostream &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="string_parse_tree.html#id612464-bb">printmatch</a>(std::ostream &amp;, charT) ;
  <span class="type">ptree_coll</span> m_next_chars;
  <span class="type"><span class="bold"><strong>short</strong></span></span> m_value;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id1765160"></a><h2>Description</h2>
<p>This class provides a quick lookup by building what amounts to a tree data structure. It also features a match function which can can handle nasty input interators by caching values as it recurses the tree so that it can backtrack as needed. </p>
<div class="refsect2" lang="en">
<a name="id1765170"></a><h3>
<a name="boost.date_time.string_parse_treeconstruct-copy-destruct"></a><code class="computeroutput">string_parse_tree</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id1110509-bb"></a>string_parse_tree(collection_type names, <span class="bold"><strong>unsigned</strong></span> <span class="bold"><strong>int</strong></span> starting_point = 0);</pre>
<p>Parameter "starting_point" designates where the numbering begins. A starting_point of zero will start the numbering at zero (Sun=0, Mon=1, ...) were a starting_point of one starts the numbering at one (Jan=1, Feb=2, ...). The default is zero, negative vaules are not allowed </p>
</li>
<li><pre class="literallayout"><a name="id1110531-bb"></a>string_parse_tree(<span class="bold"><strong>short</strong></span> value = -1);</pre></li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id1765241"></a><h3>
<a name="id732718-bb"></a><code class="computeroutput">string_parse_tree</code> public member functions</h3>
<div class="orderedlist"><ol type="1">
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id732722-bb"></a>insert(<span class="bold"><strong>const</strong></span> string_type &amp; s, <span class="bold"><strong>unsigned</strong></span> <span class="bold"><strong>short</strong></span> value) ;</pre></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>short</strong></span></span> <a name="id725907-bb"></a>match(std::istreambuf_iterator&lt; charT &gt; &amp; sitr, 
            std::istreambuf_iterator&lt; charT &gt; &amp; stream_end, 
            parse_match_result_type &amp; result, <span class="bold"><strong>unsigned</strong></span> <span class="bold"><strong>int</strong></span> &amp; level) <span class="bold"><strong>const</strong></span>;</pre>Recursive function that finds a matching string in the tree. <p>Must check match_results::has_remaining() after match() is called. This is required so the user can determine if stream iterator is already pointing to the expected character or not (match() might advance sitr to next char in stream).</p>
<p>A parse_match_result that has been returned from a failed match attempt can be sent in to the match function of a different string_parse_tree to attempt a match there. Use the iterators for the partially consumed stream, the parse_match_result object, and '0' for the level parameter. </p>
</li>
<li>
<pre class="literallayout"><span class="type">parse_match_result_type</span> 
<a name="id647172-bb"></a>match(std::istreambuf_iterator&lt; charT &gt; &amp; sitr, 
      std::istreambuf_iterator&lt; charT &gt; &amp; stream_end) <span class="bold"><strong>const</strong></span>;</pre>
<p>Must check match_results::has_remaining() after match() is called. This is required so the user can determine if stream iterator is already pointing to the expected character or not (match() might advance sitr to next char in stream). </p>
</li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id653964-bb"></a>printme(std::ostream &amp; os, <span class="bold"><strong>int</strong></span> &amp; level) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id612451-bb"></a>print(std::ostream &amp; os) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id612464-bb"></a>printmatch(std::ostream &amp; os, charT c) ;</pre></li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2001-2005 CrystalClear Software, Inc<p>Subject to the Boost Software License, Version 1.0. (See accompanying file
    <code class="filename">LICENSE_1_0.txt</code> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="parse_match_result.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../date_time/doxy.html#header.boost.date_time.string_parse_tree_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="gather_month_strings.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
