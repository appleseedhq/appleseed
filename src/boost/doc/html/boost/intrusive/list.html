<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template list</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="../../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../../intrusive/reference.html#header.boost.intrusive.list_hpp" title="Header &lt;boost/intrusive/list.hpp&gt;">
<link rel="prev" href="link_mode_type.html" title="Type link_mode_type">
<link rel="next" href="make_list.html" title="Struct template make_list">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="link_mode_type.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../intrusive/reference.html#header.boost.intrusive.list_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="make_list.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.intrusive.list"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template list</span></h2>
<p>boost::intrusive::list</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../../intrusive/reference.html#header.boost.intrusive.list_hpp" title="Header &lt;boost/intrusive/list.hpp&gt;">boost/intrusive/list.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T, <span class="bold"><strong>class</strong></span>... Options&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="list.html" title="Class template list">list</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> Config::value_traits                             <a name="boost.intrusive.list.value_traits"></a>value_traits;          
  <span class="bold"><strong>typedef</strong></span> real_value_traits::pointer                       <a name="boost.intrusive.list.pointer"></a>pointer;               
  <span class="bold"><strong>typedef</strong></span> real_value_traits::const_pointer                 <a name="boost.intrusive.list.const_pointer"></a>const_pointer;         
  <span class="bold"><strong>typedef</strong></span> std::iterator_traits&lt; pointer &gt;::value_type      <a name="boost.intrusive.list.value_type"></a>value_type;            
  <span class="bold"><strong>typedef</strong></span> std::iterator_traits&lt; pointer &gt;::reference       <a name="boost.intrusive.list.reference"></a>reference;             
  <span class="bold"><strong>typedef</strong></span> std::iterator_traits&lt; const_pointer &gt;::reference <a name="boost.intrusive.list.const_reference"></a>const_reference;       
  <span class="bold"><strong>typedef</strong></span> std::iterator_traits&lt; pointer &gt;::difference_type <a name="boost.intrusive.list.difference_type"></a>difference_type;       
  <span class="bold"><strong>typedef</strong></span> Config::size_type                                <a name="boost.intrusive.list.size_type"></a>size_type;             
  <span class="bold"><strong>typedef</strong></span> list_iterator&lt; <a class="link" href="list.html" title="Class template list">list</a>, <span class="bold"><strong>false</strong></span> &gt;                     <a name="boost.intrusive.list.iterator"></a>iterator;              
  <span class="bold"><strong>typedef</strong></span> list_iterator&lt; <a class="link" href="list.html" title="Class template list">list</a>, <span class="bold"><strong>true</strong></span> &gt;                      <a name="boost.intrusive.list.const_iterator"></a>const_iterator;        
  <span class="bold"><strong>typedef</strong></span> std::reverse_iterator&lt; iterator &gt;                <a name="boost.intrusive.list.reverse_iterator"></a>reverse_iterator;      
  <span class="bold"><strong>typedef</strong></span> std::reverse_iterator&lt; const_iterator &gt;          <a name="boost.intrusive.list.const_reverse_iterator"></a>const_reverse_iterator;
  <span class="bold"><strong>typedef</strong></span> real_value_traits::node_traits                   <a name="boost.intrusive.list.node_traits"></a>node_traits;           
  <span class="bold"><strong>typedef</strong></span> node_traits::node                                <a name="boost.intrusive.list.node"></a>node;                  
  <span class="bold"><strong>typedef</strong></span> node_traits::node_ptr                            <a name="boost.intrusive.list.node_ptr"></a>node_ptr;              
  <span class="bold"><strong>typedef</strong></span> node_traits::const_node_ptr                      <a name="boost.intrusive.list.const_node_ptr"></a>const_node_ptr;        
  <span class="bold"><strong>typedef</strong></span> <a class="link" href="circular_list_algorithms.html" title="Class template circular_list_algorithms">circular_list_algorithms</a>&lt; node_traits &gt;          <a name="boost.intrusive.list.node_algorithms"></a>node_algorithms;       

  <span class="emphasis"><em>// <a class="link" href="list.html#boost.intrusive.listconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="list.html#id2095669-bb">list</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="list.html#boost.intrusive.list.value_traits">value_traits</a> &amp; = value_traits());
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; 
    <a class="link" href="list.html#id2095706-bb">list</a>(Iterator, Iterator, <span class="bold"><strong>const</strong></span> <a class="link" href="list.html#boost.intrusive.list.value_traits">value_traits</a> &amp; = value_traits());
  <a class="link" href="list.html#id2095770-bb">~list</a>();

  <span class="emphasis"><em>// <a class="link" href="list.html#id2092676-bb">public member functions</a></em></span>
  <span class="type"><span class="bold"><strong>const</strong></span> real_value_traits &amp;</span> <a class="link" href="list.html#id2092679-bb">get_real_value_traits</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">real_value_traits &amp;</span> <a class="link" href="list.html#id2092687-bb">get_real_value_traits</a>() ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2092696-bb">push_back</a>(reference) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2092747-bb">push_front</a>(reference) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2092798-bb">pop_back</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2092837-bb">pop_back_and_dispose</a>(Disposer) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2092897-bb">pop_front</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2092935-bb">pop_front_and_dispose</a>(Disposer) ;
  <span class="type">reference</span> <a class="link" href="list.html#id2092995-bb">front</a>() ;
  <span class="type">const_reference</span> <a class="link" href="list.html#id2093026-bb">front</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">reference</span> <a class="link" href="list.html#id2093056-bb">back</a>() ;
  <span class="type">const_reference</span> <a class="link" href="list.html#id2093086-bb">back</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a class="link" href="list.html#id2093117-bb">begin</a>() ;
  <span class="type">const_iterator</span> <a class="link" href="list.html#id2093148-bb">begin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a class="link" href="list.html#id2093178-bb">cbegin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a class="link" href="list.html#id2093209-bb">end</a>() ;
  <span class="type">const_iterator</span> <a class="link" href="list.html#id2093239-bb">end</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a class="link" href="list.html#id2093269-bb">cend</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">reverse_iterator</span> <a class="link" href="list.html#id2093300-bb">rbegin</a>() ;
  <span class="type">const_reverse_iterator</span> <a class="link" href="list.html#id2093331-bb">rbegin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_reverse_iterator</span> <a class="link" href="list.html#id2093362-bb">crbegin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">reverse_iterator</span> <a class="link" href="list.html#id2093393-bb">rend</a>() ;
  <span class="type">const_reverse_iterator</span> <a class="link" href="list.html#id2093424-bb">rend</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_reverse_iterator</span> <a class="link" href="list.html#id2093455-bb">crend</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><a class="link" href="list.html#boost.intrusive.list.size_type">size_type</a></span> <a class="link" href="list.html#id2093486-bb">size</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="list.html#id2093527-bb">empty</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2093565-bb">swap</a>(<a class="link" href="list.html" title="Class template list">list</a> &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2093611-bb">shift_backwards</a>(<a class="link" href="list.html#boost.intrusive.list.size_type">size_type</a> = 1) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2093660-bb">shift_forward</a>(<a class="link" href="list.html#boost.intrusive.list.size_type">size_type</a> = 1) ;
  <span class="type">iterator</span> <a class="link" href="list.html#id2093710-bb">erase</a>(const_iterator) ;
  <span class="type">iterator</span> <a class="link" href="list.html#id2093762-bb">erase</a>(const_iterator, const_iterator) ;
  <span class="type">iterator</span> <a class="link" href="list.html#id2093830-bb">erase</a>(const_iterator, const_iterator, difference_type) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type">iterator</span> <a class="link" href="list.html#id2093904-bb">erase_and_dispose</a>(const_iterator, Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type">iterator</span> <a class="link" href="list.html#id2093978-bb">erase_and_dispose</a>(const_iterator, const_iterator, Disposer) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094058-bb">clear</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094098-bb">clear_and_dispose</a>(Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Cloner, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094159-bb">clone_from</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="list.html" title="Class template list">list</a> &amp;, Cloner, Disposer) ;
  <span class="type">iterator</span> <a class="link" href="list.html#id2094237-bb">insert</a>(const_iterator, reference) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094303-bb">insert</a>(const_iterator, Iterator, Iterator) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094374-bb">assign</a>(Iterator, Iterator) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094443-bb">dispose_and_assign</a>(Disposer, Iterator, Iterator) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094529-bb">splice</a>(const_iterator, <a class="link" href="list.html" title="Class template list">list</a> &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094591-bb">splice</a>(const_iterator, <a class="link" href="list.html" title="Class template list">list</a> &amp;, const_iterator) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094661-bb">splice</a>(const_iterator, <a class="link" href="list.html" title="Class template list">list</a> &amp;, const_iterator, const_iterator) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094737-bb">splice</a>(const_iterator, <a class="link" href="list.html" title="Class template list">list</a> &amp;, const_iterator, const_iterator, 
              difference_type) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094818-bb">sort</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Predicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094861-bb">sort</a>(Predicate) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094926-bb">merge</a>(<a class="link" href="list.html" title="Class template list">list</a> &amp;) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Predicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2094978-bb">merge</a>(<a class="link" href="list.html" title="Class template list">list</a> &amp;, Predicate) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2095050-bb">reverse</a>() ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2095088-bb">remove</a>(const_reference) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2095136-bb">remove_and_dispose</a>(const_reference, Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Pred&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2095204-bb">remove_if</a>(Pred) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2095259-bb">remove_and_dispose_if</a>(Pred, Disposer) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2095332-bb">unique</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> BinaryPredicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2095374-bb">unique</a>(BinaryPredicate) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2095429-bb">unique_and_dispose</a>(Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> BinaryPredicate, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="list.html#id2095492-bb">unique_and_dispose</a>(BinaryPredicate, Disposer) ;
  <span class="type">iterator</span> <a class="link" href="list.html#id2095565-bb">iterator_to</a>(reference) ;
  <span class="type">const_iterator</span> <a class="link" href="list.html#id2095617-bb">iterator_to</a>(const_reference) <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="list.html#id2095794-bb">public static functions</a></em></span>
  <span class="type"><span class="bold"><strong>static</strong></span> <a class="link" href="list.html" title="Class template list">list</a> &amp;</span> <a class="link" href="list.html#id2095797-bb">container_from_end_iterator</a>(iterator) ;
  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>const</strong></span> <a class="link" href="list.html" title="Class template list">list</a> &amp;</span> <a class="link" href="list.html#id2095845-bb">container_from_end_iterator</a>(const_iterator) ;
  <span class="type"><span class="bold"><strong>static</strong></span> iterator</span> <a class="link" href="list.html#id2095893-bb">s_iterator_to</a>(reference) ;
  <span class="type"><span class="bold"><strong>static</strong></span> const_iterator</span> <a class="link" href="list.html#id2095946-bb">s_iterator_to</a>(const_reference) ;
  <span class="bold"><strong>static</strong></span> <span class="type"><span class="bold"><strong>const</strong></span> <span class="bold"><strong>bool</strong></span></span> constant_time_size;
  <span class="bold"><strong>static</strong></span> <span class="type"><span class="bold"><strong>const</strong></span> <span class="bold"><strong>bool</strong></span></span> stateful_value_traits;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id2508327"></a><h2>Description</h2>
<p>The class template list is an intrusive container that mimics most of the interface of std::list as described in the C++ standard.</p>
<p>The template parameter <code class="computeroutput">T</code> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</p>
<p>The container supports the following options: <code class="computeroutput">base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</code>, <code class="computeroutput">constant_time_size&lt;&gt;</code> and <code class="computeroutput">size_type&lt;&gt;</code>. </p>
<div class="refsect2" lang="en">
<a name="id2508368"></a><h3>
<a name="boost.intrusive.listconstruct-copy-destruct"></a><code class="computeroutput">list</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id2095669-bb"></a>list(<span class="bold"><strong>const</strong></span> <a class="link" href="list.html#boost.intrusive.list.value_traits">value_traits</a> &amp; v_traits = value_traits());</pre>
<p><span class="bold"><strong>Effects</strong></span>: constructs an empty list.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant</p>
<p><span class="bold"><strong>Throws</strong></span>: If real_value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; 
  <a name="id2095706-bb"></a>list(Iterator b, Iterator e, <span class="bold"><strong>const</strong></span> <a class="link" href="list.html#boost.intrusive.list.value_traits">value_traits</a> &amp; v_traits = value_traits());</pre>
<p><span class="bold"><strong>Requires</strong></span>: Dereferencing iterator must yield an lvalue of type value_type.</p>
<p><span class="bold"><strong>Effects</strong></span>: Constructs a list equal to the range [first,last).</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear in std::distance(b, e). No copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If real_value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </p>
</li>
<li>
<pre class="literallayout"><a name="id2095770-bb"></a>~list();</pre>
<p><span class="bold"><strong>Effects</strong></span>: If it's not a safe-mode or an auto-unlink value_type the destructor does nothing (ie. no code is generated). Otherwise it detaches all elements from this. In this case the objects in the list are not deleted (i.e. no destructors are called), but the hooks according to the ValueTraits template parameter are set to their default value.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements in the list, if it's a safe-mode or auto-unlink value . Otherwise constant. </p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id2508545"></a><h3>
<a name="id2092676-bb"></a><code class="computeroutput">list</code> public member functions</h3>
<div class="orderedlist"><ol type="1">
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>const</strong></span> real_value_traits &amp;</span> <a name="id2092679-bb"></a>get_real_value_traits() <span class="bold"><strong>const</strong></span>;</pre></li>
<li><pre class="literallayout"><span class="type">real_value_traits &amp;</span> <a name="id2092687-bb"></a>get_real_value_traits() ;</pre></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2092696-bb"></a>push_back(reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be an lvalue.</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the value in the back of the list. No copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2092747-bb"></a>push_front(reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be an lvalue.</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the value in the front of the list. No copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2092798-bb"></a>pop_back() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the last element of the list. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2092837-bb"></a>pop_back_and_dispose(Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the last element of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2092897-bb"></a>pop_front() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the first element of the list. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2092935-bb"></a>pop_front_and_dispose(Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the first element of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="type">reference</span> <a name="id2092995-bb"></a>front() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a reference to the first element of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reference</span> <a name="id2093026-bb"></a>front() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reference to the first element of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">reference</span> <a name="id2093056-bb"></a>back() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a reference to the last element of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reference</span> <a name="id2093086-bb"></a>back() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reference to the last element of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2093117-bb"></a>begin() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an iterator to the first element contained in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2093148-bb"></a>begin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the first element contained in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2093178-bb"></a>cbegin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the first element contained in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2093209-bb"></a>end() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an iterator to the end of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2093239-bb"></a>end() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the end of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2093269-bb"></a>cend() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a constant iterator to the end of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">reverse_iterator</span> <a name="id2093300-bb"></a>rbegin() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a reverse_iterator pointing to the beginning of the reversed list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reverse_iterator</span> <a name="id2093331-bb"></a>rbegin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reverse_iterator pointing to the beginning of the reversed list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reverse_iterator</span> <a name="id2093362-bb"></a>crbegin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reverse_iterator pointing to the beginning of the reversed list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">reverse_iterator</span> <a name="id2093393-bb"></a>rend() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a reverse_iterator pointing to the end of the reversed list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reverse_iterator</span> <a name="id2093424-bb"></a>rend() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reverse_iterator pointing to the end of the reversed list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reverse_iterator</span> <a name="id2093455-bb"></a>crend() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reverse_iterator pointing to the end of the reversed list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><a class="link" href="list.html#boost.intrusive.list.size_type">size_type</a></span> <a name="id2093486-bb"></a>size() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns the number of the elements contained in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements contained in the list. if constant-time size option is disabled. Constant time otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id2093527-bb"></a>empty() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns true if the list contains no elements.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2093565-bb"></a>swap(<a class="link" href="list.html" title="Class template list">list</a> &amp; other) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Swaps the elements of x and *this.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2093611-bb"></a>shift_backwards(<a class="link" href="list.html#boost.intrusive.list.size_type">size_type</a> n = 1) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Moves backwards all the elements, so that the first element becomes the second, the second becomes the third... the last element becomes the first one.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of shifts.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2093660-bb"></a>shift_forward(<a class="link" href="list.html#boost.intrusive.list.size_type">size_type</a> n = 1) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Moves forward all the elements, so that the second element becomes the first, the third becomes the second... the first element becomes the last one.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of shifts.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2093710-bb"></a>erase(const_iterator i) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element pointed by i of the list. No destructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed element, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2093762-bb"></a>erase(const_iterator b, const_iterator e) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: b and e must be valid iterators to elements in *this.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element range pointed by b and e No destructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of erased elements if it's a safe-mode or auto-unlink value, or constant-time size is enabled. Constant-time otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2093830-bb"></a>erase(const_iterator b, const_iterator e, difference_type n) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: b and e must be valid iterators to elements in *this. n must be std::distance(b, e).</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element range pointed by b and e No destructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of erased elements if it's a safe-mode or auto-unlink value is enabled. Constant-time otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type">iterator</span> <a name="id2093904-bb"></a>erase_and_dispose(const_iterator i, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element pointed by i of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed element, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type">iterator</span> <a name="id2093978-bb"></a>erase_and_dispose(const_iterator b, const_iterator e, 
                             Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element range pointed by b and e No destructors are called. Disposer::operator()(pointer) is called for the removed elements.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements erased.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094058-bb"></a>clear() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases all the elements of the container. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements of the list. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094098-bb"></a>clear_and_dispose(Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases all the elements of the container. No destructors are called. Disposer::operator()(pointer) is called for the removed elements.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements of the list.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Cloner, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094159-bb"></a>clone_from(<span class="bold"><strong>const</strong></span> <a class="link" href="list.html" title="Class template list">list</a> &amp; src, Cloner cloner, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</p>
<p>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to erased plus inserted elements.</p>
<p><span class="bold"><strong>Throws</strong></span>: If cloner throws. Basic guarantee. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2094237-bb"></a>insert(const_iterator p, reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be an lvalue and p must be a valid iterator of *this.</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the value before the position pointed by p.</p>
<p><span class="bold"><strong>Returns</strong></span>: An iterator to the inserted element.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time. No copy constructors are called.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094303-bb"></a>insert(const_iterator p, Iterator b, Iterator e) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Dereferencing iterator must yield an lvalue of type value_type and p must be a valid iterator of *this.</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the range pointed by b and e before the position p. No copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements inserted.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094374-bb"></a>assign(Iterator b, Iterator e) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Dereferencing iterator must yield an lvalue of type value_type.</p>
<p><span class="bold"><strong>Effects</strong></span>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements inserted plus linear to the elements contained in the list if it's a safe-mode or auto-unlink value. Linear to the number of elements inserted in the list otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094443-bb"></a>dispose_and_assign(Disposer disposer, Iterator b, Iterator e) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Requires</strong></span>: Dereferencing iterator must yield an lvalue of type value_type.</p>
<p><span class="bold"><strong>Effects</strong></span>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called. Disposer::operator()(pointer) is called for the removed elements.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements inserted plus linear to the elements contained in the list.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094529-bb"></a>splice(const_iterator p, <a class="link" href="list.html" title="Class template list">list</a> &amp; x) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p must be a valid iterator of *this.</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094591-bb"></a>splice(const_iterator p, <a class="link" href="list.html" title="Class template list">list</a> &amp; x, const_iterator new_ele) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p must be a valid iterator of *this. new_ele must point to an element contained in list x.</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers the value pointed by new_ele, from list x to this list, before the the element pointed by p. No destructors or copy constructors are called. If p == new_ele or p == ++new_ele, this function is a null operation.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094661-bb"></a>splice(const_iterator p, <a class="link" href="list.html" title="Class template list">list</a> &amp; x, const_iterator start, 
            const_iterator end) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p must be a valid iterator of *this. start and end must point to elements contained in list x.</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers the range pointed by start and end from list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements transferred if constant-time size option is enabled. Constant-time otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094737-bb"></a>splice(const_iterator p, <a class="link" href="list.html" title="Class template list">list</a> &amp; x, const_iterator start, 
            const_iterator end, difference_type n) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p must be a valid iterator of *this. start and end must point to elements contained in list x. n == std::distance(start, end)</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers the range pointed by start and end from list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094818-bb"></a>sort() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</p>
<p><span class="bold"><strong>Throws</strong></span>: If real_value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or std::less&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Notes</strong></span>: Iterators and references are not invalidated.</p>
<p><span class="bold"><strong>Complexity</strong></span>: The number of comparisons is approximately N log N, where N is the list's size. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Predicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094861-bb"></a>sort(Predicate p) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p must be a comparison function that induces a strict weak ordering</p>
<p><span class="bold"><strong>Effects</strong></span>: This function sorts the list *this according to p. The sort is stable, that is, the relative order of equivalent elements is preserved.</p>
<p><span class="bold"><strong>Throws</strong></span>: If real_value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the predicate throws. Basic guarantee.</p>
<p><span class="bold"><strong>Notes</strong></span>: This won't throw if list_base_hook&lt;&gt; or list_member_hook are used. Iterators and references are not invalidated.</p>
<p><span class="bold"><strong>Complexity</strong></span>: The number of comparisons is approximately N log N, where N is the list's size. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094926-bb"></a>merge(<a class="link" href="list.html" title="Class template list">list</a> &amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</p>
<p><span class="bold"><strong>Throws</strong></span>: If std::less&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Predicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2094978-bb"></a>merge(<a class="link" href="list.html" title="Class template list">list</a> &amp; x, Predicate p) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</p>
<p><span class="bold"><strong>Throws</strong></span>: If the predicate throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2095050-bb"></a>reverse() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Reverses the order of elements in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: This function is linear time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2095088-bb"></a>remove(const_reference value) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Removes all the elements that compare equal to value. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time. It performs exactly size() comparisons for equality.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2095136-bb"></a>remove_and_dispose(const_reference value, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Removes all the elements that compare equal to value. Disposer::operator()(pointer) is called for every removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time. It performs exactly size() comparisons for equality.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Pred&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2095204-bb"></a>remove_if(Pred pred) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Removes all the elements for which a specified predicate is satisfied. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If pred throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time. It performs exactly size() calls to the predicate.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2095259-bb"></a>remove_and_dispose_if(Pred pred, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Removes all the elements for which a specified predicate is satisfied. Disposer::operator()(pointer) is called for every removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: If pred throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time. It performs exactly size() comparisons for equality.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2095332-bb"></a>unique() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Removes adjacent duplicate elements or adjacent elements that are equal from the list. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If std::equal_to&lt;value_type throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time (size()-1 comparisons calls to pred()).</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> BinaryPredicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2095374-bb"></a>unique(BinaryPredicate pred) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If pred throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time (size()-1 comparisons equality comparisons).</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2095429-bb"></a>unique_and_dispose(Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Removes adjacent duplicate elements or adjacent elements that are equal from the list. Disposer::operator()(pointer) is called for every removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: If std::equal_to&lt;value_type throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time (size()-1) comparisons equality comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> BinaryPredicate, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2095492-bb"></a>unique_and_dispose(BinaryPredicate pred, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. Disposer::operator()(pointer) is called for every removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: If pred throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time (size()-1) comparisons equality comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2095565-bb"></a>iterator_to(reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be a reference to a value inserted in a list.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function returns a const_iterator pointing to the element</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2095617-bb"></a>iterator_to(const_reference value) <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be a const reference to a value inserted in a list.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function returns an iterator pointing to the element.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. </p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id2512055"></a><h3>
<a name="id2095794-bb"></a><code class="computeroutput">list</code> public static functions</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <a class="link" href="list.html" title="Class template list">list</a> &amp;</span> <a name="id2095797-bb"></a>container_from_end_iterator(iterator end_iterator) ;</pre>
<p><span class="bold"><strong>Precondition</strong></span>: end_iterator must be a valid end iterator of list.</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const reference to the list associated to the end iterator</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>const</strong></span> <a class="link" href="list.html" title="Class template list">list</a> &amp;</span> <a name="id2095845-bb"></a>container_from_end_iterator(const_iterator end_iterator) ;</pre>
<p><span class="bold"><strong>Precondition</strong></span>: end_iterator must be a valid end const_iterator of list.</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const reference to the list associated to the end iterator</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> iterator</span> <a name="id2095893-bb"></a>s_iterator_to(reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be a reference to a value inserted in a list.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function returns a const_iterator pointing to the element</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. This static function is available only if the value traits is stateless. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> const_iterator</span> <a name="id2095946-bb"></a>s_iterator_to(const_reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be a const reference to a value inserted in a list.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function returns an iterator pointing to the element.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. This static function is available only if the value traits is stateless. </p>
</li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright  2005 Olaf Krzikalla, 2006-2008 Ion Gaztaaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="link_mode_type.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../intrusive/reference.html#header.boost.intrusive.list_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="make_list.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
