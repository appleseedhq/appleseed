<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template slist</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="../../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../../intrusive/reference.html#header.boost.intrusive.slist_hpp" title="Header &lt;boost/intrusive/slist.hpp&gt;">
<link rel="prev" href="sgtree_algorithms/insert_commit_data.html" title="Struct insert_commit_data">
<link rel="next" href="make_slist.html" title="Struct template make_slist">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="sgtree_algorithms/insert_commit_data.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../intrusive/reference.html#header.boost.intrusive.slist_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="make_slist.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.intrusive.slist"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template slist</span></h2>
<p>boost::intrusive::slist</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../../intrusive/reference.html#header.boost.intrusive.slist_hpp" title="Header &lt;boost/intrusive/slist.hpp&gt;">boost/intrusive/slist.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T, <span class="bold"><strong>class</strong></span>... Options&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="slist.html" title="Class template slist">slist</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> Config::value_traits                                 <a name="boost.intrusive.slist.value_traits"></a>value_traits;   
  <span class="bold"><strong>typedef</strong></span> real_value_traits::pointer                           <a name="boost.intrusive.slist.pointer"></a>pointer;        
  <span class="bold"><strong>typedef</strong></span> real_value_traits::const_pointer                     <a name="boost.intrusive.slist.const_pointer"></a>const_pointer;  
  <span class="bold"><strong>typedef</strong></span> std::iterator_traits&lt; pointer &gt;::value_type          <a name="boost.intrusive.slist.value_type"></a>value_type;     
  <span class="bold"><strong>typedef</strong></span> std::iterator_traits&lt; pointer &gt;::reference           <a name="boost.intrusive.slist.reference"></a>reference;      
  <span class="bold"><strong>typedef</strong></span> std::iterator_traits&lt; const_pointer &gt;::reference     <a name="boost.intrusive.slist.const_reference"></a>const_reference;
  <span class="bold"><strong>typedef</strong></span> std::iterator_traits&lt; pointer &gt;::difference_type     <a name="boost.intrusive.slist.difference_type"></a>difference_type;
  <span class="bold"><strong>typedef</strong></span> Config::size_type                                    <a name="boost.intrusive.slist.size_type"></a>size_type;      
  <span class="bold"><strong>typedef</strong></span> slist_iterator&lt; <a class="link" href="slist.html" title="Class template slist">slist</a>, <span class="bold"><strong>false</strong></span> &gt;                       <a name="boost.intrusive.slist.iterator"></a>iterator;       
  <span class="bold"><strong>typedef</strong></span> slist_iterator&lt; <a class="link" href="slist.html" title="Class template slist">slist</a>, <span class="bold"><strong>true</strong></span> &gt;                        <a name="boost.intrusive.slist.const_iterator"></a>const_iterator; 
  <span class="bold"><strong>typedef</strong></span> real_value_traits::node_traits                       <a name="boost.intrusive.slist.node_traits"></a>node_traits;    
  <span class="bold"><strong>typedef</strong></span> node_traits::node                                    <a name="boost.intrusive.slist.node"></a>node;           
  <span class="bold"><strong>typedef</strong></span> boost::pointer_to_other&lt; pointer, node &gt;::type       <a name="boost.intrusive.slist.node_ptr"></a>node_ptr;       
  <span class="bold"><strong>typedef</strong></span> boost::pointer_to_other&lt; pointer, <span class="bold"><strong>const</strong></span> node &gt;::type <a name="boost.intrusive.slist.const_node_ptr"></a>const_node_ptr; 
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span>                                          <a name="boost.intrusive.slist.node_algorithms"></a>node_algorithms;

  <span class="emphasis"><em>// <a class="link" href="slist.html#boost.intrusive.slistconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="slist.html#id2164955-bb">slist</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="value_traits.html" title="Struct template value_traits">value_traits</a> &amp; = value_traits());
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; 
    <a class="link" href="slist.html#id2164992-bb">slist</a>(Iterator, Iterator, <span class="bold"><strong>const</strong></span> <a class="link" href="value_traits.html" title="Struct template value_traits">value_traits</a> &amp; = value_traits());
  <a class="link" href="slist.html#id2165056-bb">~slist</a>();

  <span class="emphasis"><em>// <a class="link" href="slist.html#id2161257-bb">public member functions</a></em></span>
  <span class="type"><span class="bold"><strong>const</strong></span> real_value_traits &amp;</span> <a class="link" href="slist.html#id2161260-bb">get_real_value_traits</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">real_value_traits &amp;</span> <a class="link" href="slist.html#id2161268-bb">get_real_value_traits</a>() ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2161277-bb">clear</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2161317-bb">clear_and_dispose</a>(Disposer) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2161377-bb">push_front</a>(reference) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2161428-bb">push_back</a>(reference) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2161480-bb">pop_front</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2161519-bb">pop_front_and_dispose</a>(Disposer) ;
  <span class="type">reference</span> <a class="link" href="slist.html#id2161578-bb">front</a>() ;
  <span class="type">const_reference</span> <a class="link" href="slist.html#id2161609-bb">front</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">reference</span> <a class="link" href="slist.html#id2161639-bb">back</a>() ;
  <span class="type">const_reference</span> <a class="link" href="slist.html#id2161678-bb">back</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2161717-bb">begin</a>() ;
  <span class="type">const_iterator</span> <a class="link" href="slist.html#id2161748-bb">begin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a class="link" href="slist.html#id2161779-bb">cbegin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2161809-bb">end</a>() ;
  <span class="type">const_iterator</span> <a class="link" href="slist.html#id2161840-bb">end</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a class="link" href="slist.html#id2161870-bb">cend</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2161900-bb">before_begin</a>() ;
  <span class="type">const_iterator</span> <a class="link" href="slist.html#id2161931-bb">before_begin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a class="link" href="slist.html#id2161962-bb">cbefore_begin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><a class="link" href="size_type.html" title="Struct template size_type">size_type</a></span> <a class="link" href="slist.html#id2161993-bb">size</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="slist.html#id2162034-bb">empty</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2162072-bb">swap</a>(<a class="link" href="slist.html" title="Class template slist">slist</a> &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2162120-bb">shift_backwards</a>(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a> = 1) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2162170-bb">shift_forward</a>(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a> = 1) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Cloner, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2162220-bb">clone_from</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;, Cloner, Disposer) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2162297-bb">insert_after</a>(const_iterator, reference) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2162363-bb">insert_after</a>(const_iterator, Iterator, Iterator) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2162435-bb">insert</a>(const_iterator, reference) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2162494-bb">insert</a>(const_iterator, Iterator, Iterator) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2162569-bb">erase_after</a>(const_iterator) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2162621-bb">erase_after</a>(const_iterator, const_iterator) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2162682-bb">erase_after</a>(const_iterator, const_iterator, difference_type) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2162748-bb">erase</a>(const_iterator) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2162801-bb">erase</a>(const_iterator, const_iterator) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2162868-bb">erase</a>(const_iterator, const_iterator, difference_type) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type">iterator</span> <a class="link" href="slist.html#id2162935-bb">erase_after_and_dispose</a>(const_iterator, Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type">iterator</span> <a class="link" href="slist.html#id2163009-bb">erase_after_and_dispose</a>(const_iterator, const_iterator, Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type">iterator</span> <a class="link" href="slist.html#id2163089-bb">erase_and_dispose</a>(const_iterator, Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type">iterator</span> <a class="link" href="slist.html#id2163163-bb">erase_and_dispose</a>(const_iterator, const_iterator, Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2163245-bb">assign</a>(Iterator, Iterator) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2163314-bb">dispose_and_assign</a>(Disposer, Iterator, Iterator) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2163400-bb">splice_after</a>(const_iterator, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2163474-bb">splice_after</a>(const_iterator, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;, const_iterator) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2163544-bb">splice_after</a>(const_iterator, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;, const_iterator, const_iterator) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2163622-bb">splice_after</a>(const_iterator, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;, const_iterator, const_iterator, 
                    difference_type) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2163704-bb">splice</a>(const_iterator, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2163780-bb">splice</a>(const_iterator, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;, const_iterator) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2163851-bb">splice</a>(const_iterator, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;, const_iterator, const_iterator) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2163931-bb">splice</a>(const_iterator, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;, const_iterator, const_iterator, 
              difference_type) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Predicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164014-bb">sort</a>(Predicate) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164070-bb">sort</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Predicate&gt; <span class="type">iterator</span> <a class="link" href="slist.html#id2164124-bb">merge</a>(<a class="link" href="slist.html" title="Class template slist">slist</a> &amp;, Predicate) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164205-bb">merge</a>(<a class="link" href="slist.html" title="Class template slist">slist</a> &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164257-bb">reverse</a>() ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164295-bb">remove</a>(const_reference) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164344-bb">remove_and_dispose</a>(const_reference, Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Pred&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164412-bb">remove_if</a>(Pred) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164467-bb">remove_and_dispose_if</a>(Pred, Disposer) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164540-bb">unique</a>() ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> BinaryPredicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164582-bb">unique</a>(BinaryPredicate) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164637-bb">unique_and_dispose</a>(Disposer) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> BinaryPredicate, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
    <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2164700-bb">unique_and_dispose</a>(BinaryPredicate, Disposer) ;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2164773-bb">iterator_to</a>(reference) ;
  <span class="type">const_iterator</span> <a class="link" href="slist.html#id2164825-bb">iterator_to</a>(const_reference) <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a class="link" href="slist.html#id2164877-bb">previous</a>(iterator) ;
  <span class="type">const_iterator</span> <a class="link" href="slist.html#id2164916-bb">previous</a>(const_iterator) <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="slist.html#id2165079-bb">public static functions</a></em></span>
  <span class="type"><span class="bold"><strong>static</strong></span> <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;</span> <a class="link" href="slist.html#id2165082-bb">container_from_end_iterator</a>(iterator) ;
  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>const</strong></span> <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;</span> <a class="link" href="slist.html#id2165130-bb">container_from_end_iterator</a>(const_iterator) ;
  <span class="type"><span class="bold"><strong>static</strong></span> iterator</span> <a class="link" href="slist.html#id2165178-bb">s_iterator_to</a>(reference) ;
  <span class="type"><span class="bold"><strong>static</strong></span> const_iterator</span> <a class="link" href="slist.html#id2165232-bb">s_iterator_to</a>(const_reference) ;

  <span class="emphasis"><em>// <a class="link" href="slist.html#id2165285-bb">private member functions</a></em></span>
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165288-bb">priv_splice_after</a>(node_ptr, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;, node_ptr, node_ptr) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165321-bb">priv_reverse</a>(<span class="emphasis"><em>unspecified</em></span>) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165336-bb">priv_reverse</a>(<span class="emphasis"><em>unspecified</em></span>) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165350-bb">priv_shift_backwards</a>(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a>, <span class="emphasis"><em>unspecified</em></span>) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165371-bb">priv_shift_backwards</a>(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a>, <span class="emphasis"><em>unspecified</em></span>) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165393-bb">priv_shift_forward</a>(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a>, <span class="emphasis"><em>unspecified</em></span>) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165414-bb">priv_shift_forward</a>(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a>, <span class="emphasis"><em>unspecified</em></span>) ;

  <span class="emphasis"><em>// <a class="link" href="slist.html#id2165435-bb">private static functions</a></em></span>
  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165439-bb">priv_swap_cache_last</a>(<a class="link" href="slist.html" title="Class template slist">slist</a> *, <a class="link" href="slist.html" title="Class template slist">slist</a> *) ;
  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165463-bb">priv_swap_lists</a>(node_ptr, node_ptr, <span class="emphasis"><em>unspecified</em></span>) ;
  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="slist.html#id2165488-bb">priv_swap_lists</a>(node_ptr, node_ptr, <span class="emphasis"><em>unspecified</em></span>) ;
  <span class="type"><span class="bold"><strong>static</strong></span> <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;</span> <a class="link" href="slist.html#id2165514-bb">priv_container_from_end_iterator</a>(<span class="bold"><strong>const</strong></span> const_iterator &amp;) ;
  <span class="bold"><strong>static</strong></span> <span class="type"><span class="bold"><strong>const</strong></span> <span class="bold"><strong>bool</strong></span></span> constant_time_size;
  <span class="bold"><strong>static</strong></span> <span class="type"><span class="bold"><strong>const</strong></span> <span class="bold"><strong>bool</strong></span></span> stateful_value_traits;
  <span class="bold"><strong>static</strong></span> <span class="type"><span class="bold"><strong>const</strong></span> <span class="bold"><strong>bool</strong></span></span> linear;
  <span class="bold"><strong>static</strong></span> <span class="type"><span class="bold"><strong>const</strong></span> <span class="bold"><strong>bool</strong></span></span> cache_last;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id2620159"></a><h2>Description</h2>
<p>The class template slist is an intrusive container, that encapsulates a singly-linked list. You can use such a list to squeeze the last bit of performance from your application. Unfortunately, the little gains come with some huge drawbacks. A lot of member functions can't be implemented as efficiently as for standard containers. To overcome this limitation some other member functions with rather unusual semantics have to be introduced.</p>
<p>The template parameter <code class="computeroutput">T</code> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</p>
<p>The container supports the following options: <code class="computeroutput">base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</code>, <code class="computeroutput">constant_time_size&lt;&gt;</code>, <code class="computeroutput">size_type&lt;&gt;</code>, <code class="computeroutput">linear&lt;&gt;</code> and <code class="computeroutput">cache_last&lt;&gt;</code>.</p>
<p>The iterators of slist are forward iterators. slist provides a static function called "previous" to compute the previous iterator of a given iterator. This function has linear complexity. To improve the usability esp. with the '*_after' functions, ++end() == begin() and previous(begin()) == end() are defined. An new special function "before_begin()" is defined, which returns an iterator that points one less the beginning of the list: ++before_begin() == begin() </p>
<div class="refsect2" lang="en">
<a name="id2620226"></a><h3>
<a name="boost.intrusive.slistconstruct-copy-destruct"></a><code class="computeroutput">slist</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id2164955-bb"></a>slist(<span class="bold"><strong>const</strong></span> <a class="link" href="value_traits.html" title="Struct template value_traits">value_traits</a> &amp; v_traits = value_traits());</pre>
<p><span class="bold"><strong>Effects</strong></span>: constructs an empty list.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant</p>
<p><span class="bold"><strong>Throws</strong></span>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; 
  <a name="id2164992-bb"></a>slist(Iterator b, Iterator e, 
        <span class="bold"><strong>const</strong></span> <a class="link" href="value_traits.html" title="Struct template value_traits">value_traits</a> &amp; v_traits = value_traits());</pre>
<p><span class="bold"><strong>Requires</strong></span>: Dereferencing iterator must yield an lvalue of type value_type.</p>
<p><span class="bold"><strong>Effects</strong></span>: Constructs a list equal to [first,last).</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear in std::distance(b, e). No copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </p>
</li>
<li>
<pre class="literallayout"><a name="id2165056-bb"></a>~slist();</pre>
<p><span class="bold"><strong>Effects</strong></span>: If it's a safe-mode or auto-unlink value, the destructor does nothing (ie. no code is generated). Otherwise it detaches all elements from this. In this case the objects in the list are not deleted (i.e. no destructors are called), but the hooks according to the value_traits template parameter are set to their default value.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements in the list, if it's a safe-mode or auto-unlink value. Otherwise constant. </p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id2620401"></a><h3>
<a name="id2161257-bb"></a><code class="computeroutput">slist</code> public member functions</h3>
<div class="orderedlist"><ol type="1">
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>const</strong></span> real_value_traits &amp;</span> <a name="id2161260-bb"></a>get_real_value_traits() <span class="bold"><strong>const</strong></span>;</pre></li>
<li><pre class="literallayout"><span class="type">real_value_traits &amp;</span> <a name="id2161268-bb"></a>get_real_value_traits() ;</pre></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2161277-bb"></a>clear() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases all the elements of the container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements of the list. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2161317-bb"></a>clear_and_dispose(Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases all the elements of the container Disposer::operator()(pointer) is called for the removed elements.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements of the list.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2161377-bb"></a>push_front(reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be an lvalue.</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the value in the front of the list. No copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2161428-bb"></a>push_back(reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be an lvalue.</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the value in the back of the list. No copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. This function is only available is cache_last&lt;&gt; is true. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2161480-bb"></a>pop_front() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the first element of the list. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2161519-bb"></a>pop_front_and_dispose(Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the first element of the list. Disposer::operator()(pointer) is called for the removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="type">reference</span> <a name="id2161578-bb"></a>front() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a reference to the first element of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reference</span> <a name="id2161609-bb"></a>front() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reference to the first element of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">reference</span> <a name="id2161639-bb"></a>back() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a reference to the last element of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. This function is only available is cache_last&lt;&gt; is true. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reference</span> <a name="id2161678-bb"></a>back() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reference to the last element of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. This function is only available is cache_last&lt;&gt; is true. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2161717-bb"></a>begin() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an iterator to the first element contained in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2161748-bb"></a>begin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the first element contained in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2161779-bb"></a>cbegin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the first element contained in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2161809-bb"></a>end() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an iterator to the end of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2161840-bb"></a>end() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the end of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2161870-bb"></a>cend() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the end of the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2161900-bb"></a>before_begin() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an iterator that points to a position before the first element. Equivalent to "end()"</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2161931-bb"></a>before_begin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an iterator that points to a position before the first element. Equivalent to "end()"</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2161962-bb"></a>cbefore_begin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an iterator that points to a position before the first element. Equivalent to "end()"</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><a class="link" href="size_type.html" title="Struct template size_type">size_type</a></span> <a name="id2161993-bb"></a>size() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns the number of the elements contained in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements contained in the list. if constant_time_size is false. Constant time otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id2162034-bb"></a>empty() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns true if the list contains no elements.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2162072-bb"></a>swap(<a class="link" href="slist.html" title="Class template slist">slist</a> &amp; other) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Swaps the elements of x and *this.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements of both lists. Constant-time if linear&lt;&gt; and/or cache_last&lt;&gt; options are used.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2162120-bb"></a>shift_backwards(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a> n = 1) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Moves backwards all the elements, so that the first element becomes the second, the second becomes the third... the last element becomes the first one.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements plus the number shifts.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2162170-bb"></a>shift_forward(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a> n = 1) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Moves forward all the elements, so that the second element becomes the first, the third becomes the second... the first element becomes the last one.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements plus the number shifts.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Cloner, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2162220-bb"></a>clone_from(<span class="bold"><strong>const</strong></span> <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; src, Cloner cloner, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</p>
<p>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to erased plus inserted elements.</p>
<p><span class="bold"><strong>Throws</strong></span>: If cloner throws. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2162297-bb"></a>insert_after(const_iterator prev_p, reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be an lvalue and prev_p must point to an element contained by the list or to end().</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the value after the position pointed by prev_p. No copy constructor is called.</p>
<p><span class="bold"><strong>Returns</strong></span>: An iterator to the inserted element.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2162363-bb"></a>insert_after(const_iterator prev_p, Iterator first, Iterator last) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Dereferencing iterator must yield an lvalue of type value_type and prev_p must point to an element contained by the list or to the end node.</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the [first, last) after the position prev_p.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements inserted.</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2162435-bb"></a>insert(const_iterator p, reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be an lvalue and p must point to an element contained by the list or to end().</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the value before the position pointed by p. No copy constructor is called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements before p. Constant-time if cache_last&lt;&gt; is true and p == end().</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2162494-bb"></a>insert(const_iterator p, Iterator b, Iterator e) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Dereferencing iterator must yield an lvalue of type value_type and p must point to an element contained by the list or to the end node.</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts the pointed by b and e before the position p. No copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements inserted plus linear to the elements before b. Linear to the number of elements to insert if cache_last&lt;&gt; option is true and p == end().</p>
<p><span class="bold"><strong>Note</strong></span>: Does not affect the validity of iterators and references. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2162569-bb"></a>erase_after(const_iterator prev) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element after the element pointed by prev of the list. No destructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2162621-bb"></a>erase_after(const_iterator before_first, const_iterator last) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the range (before_first, last) from the list. No destructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of erased elements if it's a safe-mode , auto-unlink value or constant-time size is activated. Constant time otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2162682-bb"></a>erase_after(const_iterator before_first, const_iterator last, 
                     difference_type n) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the range (before_first, last) from the list. n must be std::distance(before_first, last) - 1. No destructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: constant-time if link_mode is normal_link. Linear to the elements (last - before_first) otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2162748-bb"></a>erase(const_iterator i) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element pointed by i of the list. No destructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed element, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the elements before i.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2162801-bb"></a>erase(const_iterator first, const_iterator last) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: first and last must be valid iterator to elements in *this.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the range pointed by b and e. No destructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the elements before last.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2162868-bb"></a>erase(const_iterator first, const_iterator last, difference_type n) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the range [first, last) from the list. n must be std::distance(first, last). No destructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: linear to the elements before first if link_mode is normal_link and constant_time_size is activated. Linear to the elements before last otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type">iterator</span> <a name="id2162935-bb"></a>erase_after_and_dispose(const_iterator prev, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element after the element pointed by prev of the list. Disposer::operator()(pointer) is called for the removed element.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type">iterator</span> <a name="id2163009-bb"></a>erase_after_and_dispose(const_iterator before_first, 
                                   const_iterator last, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the range (before_first, last) from the list. Disposer::operator()(pointer) is called for the removed elements.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Lineal to the elements (last - before_first + 1).</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type">iterator</span> <a name="id2163089-bb"></a>erase_and_dispose(const_iterator i, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element pointed by i of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed element, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the elements before i.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type">iterator</span> <a name="id2163163-bb"></a>erase_and_dispose(const_iterator first, const_iterator last, 
                             Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: first and last must be valid iterator to elements in *this. Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases the range pointed by b and e. No destructors are called. Disposer::operator()(pointer) is called for the removed elements.</p>
<p><span class="bold"><strong>Returns</strong></span>: the first element remaining beyond the removed elements, or end() if no such element exists.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of erased elements plus linear to the elements before first.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2163245-bb"></a>assign(Iterator b, Iterator e) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Dereferencing iterator must yield an lvalue of type value_type.</p>
<p><span class="bold"><strong>Effects</strong></span>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements inserted plus linear to the elements contained in the list if it's a safe-mode or auto-unlink value. Linear to the number of elements inserted in the list otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Iterator, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2163314-bb"></a>dispose_and_assign(Disposer disposer, Iterator b, Iterator e) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Requires</strong></span>: Dereferencing iterator must yield an lvalue of type value_type.</p>
<p><span class="bold"><strong>Effects</strong></span>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called. Disposer::operator()(pointer) is called for the removed elements.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements inserted plus linear to the elements contained in the list.</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates the iterators (but not the references) to the erased elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2163400-bb"></a>splice_after(const_iterator prev, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: prev is an iterator to an element or x.end()/x.before_begin() in x.</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers all the elements of list x to this list, after the the element pointed by prev. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: The last element inserted of x or prev if x is empty. This iterator can be used as new "prev" iterator for a new splice_after call. that will splice new values after the previously spliced values.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the elements contained in x. Constant-time if cache_last&lt;&gt; option is true.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2163474-bb"></a>splice_after(const_iterator prev_pos, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x, const_iterator prev_ele) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: prev must point to an element contained by this list or to the before_begin() element. prev_ele must point to an element contained in list x or must be x.before_begin().</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers the element after prev_ele, from list x to this list, after the element pointed by prev. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2163544-bb"></a>splice_after(const_iterator prev_pos, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x, 
                  const_iterator before_first, const_iterator before_last) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: prev_pos must be a dereferenceable iterator in *this or be before_begin(), and before_first and before_last belong to x and ++before_first != x.end() &amp;&amp; before_last != x.end().</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers the range (before_first, before_last] from list x to this list, after the element pointed by prev_pos. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements transferred if constant_time_size is true. Constant-time otherwise.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2163622-bb"></a>splice_after(const_iterator prev_pos, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x, 
                  const_iterator before_first, const_iterator before_last, 
                  difference_type n) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: prev_pos must be a dereferenceable iterator in *this or be before_begin(), and before_first and before_last belong to x and ++before_first != x.end() &amp;&amp; before_last != x.end() and n == std::distance(before_first, before_last).</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers the range (before_first, before_last] from list x to this list, after the element pointed by p. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2163704-bb"></a>splice(const_iterator it, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: it is an iterator to an element in x.</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers all the elements of list x to this list, before the the element pointed by it. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Returns</strong></span>: The last element inserted of x or the previous element of it if x is empty. This iterator can be used as new "prev" iterator for a new splice call. that will splice new values after the previously spliced values.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the elements contained in x plus linear to the elements before it. Linear to the elements before it if cache_last&lt;&gt; option is true. Constant-time if cache_last&lt;&gt; option is true and it == end().</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2163780-bb"></a>splice(const_iterator pos, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x, const_iterator elem) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: it p must be a valid iterator of *this. elem must point to an element contained in list x.</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers the element elem, from list x to this list, before the element pointed by pos. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the elements before pos and before elem. Linear to the elements before elem if cache_last&lt;&gt; option is true and pos == end().</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2163851-bb"></a>splice(const_iterator pos, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x, const_iterator first, 
            const_iterator last) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: pos must be a dereferenceable iterator in *this and first and last belong to x and first and last a valid range on x.</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers the range [first, last) from list x to this list, before the element pointed by pos. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the sum of elements before pos, first, and last plus linear to the number of elements transferred if constant_time_size is true. Linear to the sum of elements before first, and last plus linear to the number of elements transferred if constant_time_size is true if cache_last&lt;&gt; is true and pos == end()</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2163931-bb"></a>splice(const_iterator pos, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x, const_iterator first, 
            const_iterator last, difference_type n) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: pos must be a dereferenceable iterator in *this and first and last belong to x and first and last a valid range on x. n == std::distance(first, last).</p>
<p><span class="bold"><strong>Effects</strong></span>: Transfers the range [first, last) from list x to this list, before the element pointed by pos. No destructors or copy constructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the sum of elements before pos, first, and last. Linear to the sum of elements before first and last if cache_last&lt;&gt; is true and pos == end().</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Predicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164014-bb"></a>sort(Predicate p) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</p>
<p><span class="bold"><strong>Throws</strong></span>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the predicate throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: The number of comparisons is approximately N log N, where N is the list's size.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164070-bb"></a>sort() ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</p>
<p><span class="bold"><strong>Throws</strong></span>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or std::less&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Predicate&gt; <span class="type">iterator</span> <a name="id2164124-bb"></a>merge(<a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x, Predicate p) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</p>
<p><span class="bold"><strong>Returns</strong></span>: An iterator to the last transferred value, end() is x is empty.</p>
<p><span class="bold"><strong>Throws</strong></span>: If the predicate throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164205-bb"></a>merge(<a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</p>
<p><span class="bold"><strong>Throws</strong></span>: if std::less&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164257-bb"></a>reverse() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Reverses the order of elements in the list.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: This function is linear to the contained elements.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164295-bb"></a>remove(const_reference value) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Removes all the elements that compare equal to value. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time. It performs exactly size() comparisons for equality.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly size() comparisons for equality. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164344-bb"></a>remove_and_dispose(const_reference value, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Removes all the elements that compare equal to value. Disposer::operator()(pointer) is called for every removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time. It performs exactly size() comparisons for equality.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Pred&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164412-bb"></a>remove_if(Pred pred) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Removes all the elements for which a specified predicate is satisfied. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If pred throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time. It performs exactly size() calls to the predicate.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164467-bb"></a>remove_and_dispose_if(Pred pred, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Removes all the elements for which a specified predicate is satisfied. Disposer::operator()(pointer) is called for every removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: If pred throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time. It performs exactly size() comparisons for equality.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164540-bb"></a>unique() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Removes adjacent duplicate elements or adjacent elements that are equal from the list. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time (size()-1) comparisons calls to pred()).</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> BinaryPredicate&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164582-bb"></a>unique(BinaryPredicate pred) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. No destructors are called.</p>
<p><span class="bold"><strong>Throws</strong></span>: If the predicate throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time (size()-1) comparisons equality comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164637-bb"></a>unique_and_dispose(Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. Disposer::operator()(pointer) is called for every removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time (size()-1) comparisons equality comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> BinaryPredicate, <span class="bold"><strong>typename</strong></span> Disposer&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2164700-bb"></a>unique_and_dispose(BinaryPredicate pred, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><span class="bold"><strong>Effects</strong></span>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. Disposer::operator()(pointer) is called for every removed element.</p>
<p><span class="bold"><strong>Throws</strong></span>: If the predicate throws. Basic guarantee.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time (size()-1) comparisons equality comparisons.</p>
<p><span class="bold"><strong>Note</strong></span>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2164773-bb"></a>iterator_to(reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be a reference to a value inserted in a list.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function returns a const_iterator pointing to the element</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2164825-bb"></a>iterator_to(const_reference value) <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be a const reference to a value inserted in a list.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function returns an iterator pointing to the element.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id2164877-bb"></a>previous(iterator i) ;</pre>
<p><span class="bold"><strong>Returns</strong></span>: The iterator to the element before i in the list. Returns the end-iterator, if either i is the begin-iterator or the list is empty.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements before i. Constant if cache_last&lt;&gt; is true and i == end(). </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id2164916-bb"></a>previous(const_iterator i) <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Returns</strong></span>: The const_iterator to the element before i in the list. Returns the end-const_iterator, if either i is the begin-const_iterator or the list is empty.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of elements before i. Constant if cache_last&lt;&gt; is true and i == end(). </p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id2642013"></a><h3>
<a name="id2165079-bb"></a><code class="computeroutput">slist</code> public static functions</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;</span> <a name="id2165082-bb"></a>container_from_end_iterator(iterator end_iterator) ;</pre>
<p><span class="bold"><strong>Precondition</strong></span>: end_iterator must be a valid end iterator of slist.</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const reference to the slist associated to the end iterator</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>const</strong></span> <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;</span> <a name="id2165130-bb"></a>container_from_end_iterator(const_iterator end_iterator) ;</pre>
<p><span class="bold"><strong>Precondition</strong></span>: end_iterator must be a valid end const_iterator of slist.</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const reference to the slist associated to the end iterator</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> iterator</span> <a name="id2165178-bb"></a>s_iterator_to(reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be a reference to a value inserted in a list.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function returns a const_iterator pointing to the element</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. This static function is available only if the value traits is stateless. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> const_iterator</span> <a name="id2165232-bb"></a>s_iterator_to(const_reference value) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: value must be a const reference to a value inserted in a list.</p>
<p><span class="bold"><strong>Effects</strong></span>: This function returns an iterator pointing to the element.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.</p>
<p><span class="bold"><strong>Note</strong></span>: Iterators and references are not invalidated. This static function is available only if the value traits is stateless. </p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id2642272"></a><h3>
<a name="id2165285-bb"></a><code class="computeroutput">slist</code> private member functions</h3>
<div class="orderedlist"><ol type="1">
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2165288-bb"></a>priv_splice_after(node_ptr prev_pos_n, <a class="link" href="slist.html" title="Class template slist">slist</a> &amp; x, 
                       node_ptr before_first_n, node_ptr before_last_n) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2165321-bb"></a>priv_reverse(<span class="emphasis"><em>unspecified</em></span>) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2165336-bb"></a>priv_reverse(<span class="emphasis"><em>unspecified</em></span>) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2165350-bb"></a>priv_shift_backwards(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a> n, <span class="emphasis"><em>unspecified</em></span>) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2165371-bb"></a>priv_shift_backwards(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a> n, <span class="emphasis"><em>unspecified</em></span>) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2165393-bb"></a>priv_shift_forward(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a> n, <span class="emphasis"><em>unspecified</em></span>) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2165414-bb"></a>priv_shift_forward(<a class="link" href="size_type.html" title="Struct template size_type">size_type</a> n, <span class="emphasis"><em>unspecified</em></span>) ;</pre></li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id2642491"></a><h3>
<a name="id2165435-bb"></a><code class="computeroutput">slist</code> private static functions</h3>
<div class="orderedlist"><ol type="1">
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id2165439-bb"></a>priv_swap_cache_last(<a class="link" href="slist.html" title="Class template slist">slist</a> * this_impl, <a class="link" href="slist.html" title="Class template slist">slist</a> * other_impl) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id2165463-bb"></a>priv_swap_lists(node_ptr this_node, node_ptr other_node, 
                            <span class="emphasis"><em>unspecified</em></span>) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id2165488-bb"></a>priv_swap_lists(node_ptr this_node, node_ptr other_node, 
                            <span class="emphasis"><em>unspecified</em></span>) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <a class="link" href="slist.html" title="Class template slist">slist</a> &amp;</span> 
<a name="id2165514-bb"></a>priv_container_from_end_iterator(<span class="bold"><strong>const</strong></span> const_iterator &amp; end_iterator) ;</pre></li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright  2005 Olaf Krzikalla, 2006-2008 Ion Gaztaaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="sgtree_algorithms/insert_commit_data.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../intrusive/reference.html#header.boost.intrusive.slist_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="make_slist.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
