<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template adaptive_pool</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="../../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../../boost_interprocess_reference.html#header.boost.interprocess.allocators.adaptive_pool_hpp" title="Header &lt;boost/interprocess/allocators/adaptive_pool.hpp&gt;">
<link rel="prev" href="../../boost_interprocess_reference.html" title="Boost.Interprocess Reference">
<link rel="next" href="adaptive_pool/rebind.html" title="Struct template rebind">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../../boost_interprocess_reference.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_interprocess_reference.html#header.boost.interprocess.allocators.adaptive_pool_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="adaptive_pool/rebind.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.interprocess.adaptive_pool"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template adaptive_pool</span></h2>
<p>boost::interprocess::adaptive_pool</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../../boost_interprocess_reference.html#header.boost.interprocess.allocators.adaptive_pool_hpp" title="Header &lt;boost/interprocess/allocators/adaptive_pool.hpp&gt;">boost/interprocess/allocators/adaptive_pool.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T, <span class="bold"><strong>typename</strong></span> SegmentManager, std::size_t NodesPerBlock, 
         std::size_t MaxFreeBlocks, <span class="bold"><strong>unsigned</strong></span> <span class="bold"><strong>char</strong></span> OverheadPercent&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> implementation_defined::segment_manager <a name="boost.interprocess.adaptive_pool.segment_manager"></a>segment_manager;
  <span class="bold"><strong>typedef</strong></span> segment_manager::void_pointer           <a name="boost.interprocess.adaptive_pool.void_pointer"></a>void_pointer;   
  <span class="bold"><strong>typedef</strong></span> implementation_defined::pointer         <a name="boost.interprocess.adaptive_pool.pointer"></a>pointer;        
  <span class="bold"><strong>typedef</strong></span> implementation_defined::const_pointer   <a name="boost.interprocess.adaptive_pool.const_pointer"></a>const_pointer;  
  <span class="bold"><strong>typedef</strong></span> T                                       <a name="boost.interprocess.adaptive_pool.value_type"></a>value_type;     
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span>                             <a name="boost.interprocess.adaptive_pool.reference"></a>reference;      
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span>                             <a name="boost.interprocess.adaptive_pool.const_reference"></a>const_reference;
  <span class="bold"><strong>typedef</strong></span> std::size_t                             <a name="boost.interprocess.adaptive_pool.size_type"></a>size_type;      
  <span class="bold"><strong>typedef</strong></span> std::ptrdiff_t                          <a name="boost.interprocess.adaptive_pool.difference_type"></a>difference_type;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T2&gt; 
  <span class="bold"><strong>struct</strong></span> <a class="link" href="adaptive_pool/rebind.html" title="Struct template rebind">rebind</a> {
    <span class="emphasis"><em>// types</em></span>
    <span class="bold"><strong>typedef</strong></span> <a class="link" href="adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; <a class="link" href="adaptive_pool/rebind.html#boost.interprocess.adaptive_pool.rebind.other">other</a>;
  };

  <span class="emphasis"><em>// <a class="link" href="adaptive_pool.html#boost.interprocess.adaptive_poolconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="adaptive_pool.html#id1738314-bb">adaptive_pool</a>(<a class="link" href="adaptive_pool.html#boost.interprocess.adaptive_pool.segment_manager">segment_manager</a> *);
  <a class="link" href="adaptive_pool.html#id1738330-bb">adaptive_pool</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a> &amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T2&gt; 
    <a class="link" href="adaptive_pool.html#id1738346-bb">adaptive_pool</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T2, <span class="bold"><strong>typename</strong></span> SegmentManager2, std::size_t N2, 
           std::size_t F2, <span class="bold"><strong>unsigned</strong></span> <span class="bold"><strong>char</strong></span> OP2&gt; 
    adaptive_pool&amp; 
    <a class="link" href="adaptive_pool.html#id1737873-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a>&lt; T2, SegmentManager2, N2, F2, OP2 &gt; &amp;);
  <a class="link" href="adaptive_pool.html#id1738371-bb">~adaptive_pool</a>();

  <span class="emphasis"><em>// <a class="link" href="adaptive_pool.html#id1737921-bb">public member functions</a></em></span>
  <span class="type"><span class="bold"><strong>void</strong></span> *</span> <a class="link" href="adaptive_pool.html#id1737924-bb">get_node_pool</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><a class="link" href="adaptive_pool.html#boost.interprocess.adaptive_pool.segment_manager">segment_manager</a> *</span> <a class="link" href="adaptive_pool.html#id1737936-bb">get_segment_manager</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a class="link" href="adaptive_pool.html#id1737950-bb">max_size</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">pointer</span> <a class="link" href="adaptive_pool.html#id1737963-bb">allocate</a>(size_type, cvoid_pointer = 0) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="adaptive_pool.html#id1737989-bb">deallocate</a>(<span class="bold"><strong>const</strong></span> pointer &amp;, size_type) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="adaptive_pool.html#id1738012-bb">deallocate_free_blocks</a>() ;
  <span class="type">pointer</span> <a class="link" href="adaptive_pool.html#id1738024-bb">address</a>(reference) <span class="bold"><strong>const</strong></span>;
  <span class="type">const_pointer</span> <a class="link" href="adaptive_pool.html#id1738042-bb">address</a>(const_reference) <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="adaptive_pool.html#id1738060-bb">construct</a>(<span class="bold"><strong>const</strong></span> pointer &amp;, const_reference) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="adaptive_pool.html#id1738083-bb">destroy</a>(<span class="bold"><strong>const</strong></span> pointer &amp;) ;
  <span class="type">size_type</span> <a class="link" href="adaptive_pool.html#id1738101-bb">size</a>(<span class="bold"><strong>const</strong></span> pointer &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">std::pair&lt; pointer, <span class="bold"><strong>bool</strong></span> &gt;</span> 
  <a class="link" href="adaptive_pool.html#id1738120-bb">allocation_command</a>(boost::interprocess::allocation_type, size_type, 
                     size_type, size_type &amp;, <span class="bold"><strong>const</strong></span> pointer &amp; = 0) ;
  <span class="type">multiallocation_chain</span> <a class="link" href="adaptive_pool.html#id1738160-bb">allocate_many</a>(size_type, std::size_t) ;
  <span class="type">multiallocation_chain</span> <a class="link" href="adaptive_pool.html#id1738187-bb">allocate_many</a>(<span class="bold"><strong>const</strong></span> size_type *, size_type) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="adaptive_pool.html#id1738212-bb">deallocate_many</a>(multiallocation_chain) ;
  <span class="type">pointer</span> <a class="link" href="adaptive_pool.html#id1738234-bb">allocate_one</a>() ;
  <span class="type">multiallocation_chain</span> <a class="link" href="adaptive_pool.html#id1738248-bb">allocate_individual</a>(std::size_t) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="adaptive_pool.html#id1738271-bb">deallocate_one</a>(<span class="bold"><strong>const</strong></span> pointer &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="adaptive_pool.html#id1738291-bb">deallocate_individual</a>(multiallocation_chain) ;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id2123448"></a><h2>Description</h2>
<p>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc...</p>
<p>This node allocator shares a segregated storage between all instances of adaptive_pool with equal sizeof(T) placed in the same segment group. NodesPerBlock is the number of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</p>
<p>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </p>
<div class="refsect2" lang="en">
<a name="id2123472"></a><h3>
<a name="boost.interprocess.adaptive_poolconstruct-copy-destruct"></a><code class="computeroutput">adaptive_pool</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id1738314-bb"></a>adaptive_pool(<a class="link" href="adaptive_pool.html#boost.interprocess.adaptive_pool.segment_manager">segment_manager</a> * segment_mngr);</pre>
<p>Not assignable from other adaptive_pool Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </p>
</li>
<li>
<pre class="literallayout"><a name="id1738330-bb"></a>adaptive_pool(<span class="bold"><strong>const</strong></span> <a class="link" href="adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a> &amp; other);</pre>
<p>Copy constructor from other adaptive_pool. Increments the reference count of the associated node pool. Never throws </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T2&gt; 
  <a name="id1738346-bb"></a>adaptive_pool(<span class="bold"><strong>const</strong></span> <a class="link" href="adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp; other);</pre>
<p>Copy constructor from related adaptive_pool. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T2, <span class="bold"><strong>typename</strong></span> SegmentManager2, std::size_t N2, 
         std::size_t F2, <span class="bold"><strong>unsigned</strong></span> <span class="bold"><strong>char</strong></span> OP2&gt; 
  adaptive_pool&amp; 
  <a name="id1737873-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="bold"><strong>const</strong></span> <a class="link" href="adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a>&lt; T2, SegmentManager2, N2, F2, OP2 &gt; &amp;);</pre>
<p>Not assignable from related adaptive_pool </p>
</li>
<li>
<pre class="literallayout"><a name="id1738371-bb"></a>~adaptive_pool();</pre>
<p>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id2123680"></a><h3>
<a name="id1737921-bb"></a><code class="computeroutput">adaptive_pool</code> public member functions</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span> *</span> <a name="id1737924-bb"></a>get_node_pool() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns a pointer to the node pool. Never throws </p>
</li>
<li>
<pre class="literallayout"><span class="type"><a class="link" href="adaptive_pool.html#boost.interprocess.adaptive_pool.segment_manager">segment_manager</a> *</span> <a name="id1737936-bb"></a>get_segment_manager() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns the segment manager. Never throws </p>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id1737950-bb"></a>max_size() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns the number of elements that could be allocated. Never throws </p>
</li>
<li>
<pre class="literallayout"><span class="type">pointer</span> <a name="id1737963-bb"></a>allocate(size_type count, cvoid_pointer hint = 0) ;</pre>
<p>Allocate memory for an array of count elements. Throws boost::interprocess::bad_alloc if there is no enough memory </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1737989-bb"></a>deallocate(<span class="bold"><strong>const</strong></span> pointer &amp; ptr, size_type count) ;</pre>
<p>Deallocate allocated memory. Never throws </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1738012-bb"></a>deallocate_free_blocks() ;</pre>
<p>Deallocates all free blocks of the pool </p>
</li>
<li>
<pre class="literallayout"><span class="type">pointer</span> <a name="id1738024-bb"></a>address(reference value) <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns address of mutable object. Never throws </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_pointer</span> <a name="id1738042-bb"></a>address(const_reference value) <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns address of non mutable object. Never throws </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1738060-bb"></a>construct(<span class="bold"><strong>const</strong></span> pointer &amp; ptr, const_reference v) ;</pre>
<p>Copy construct an object. Throws if T's copy constructor throws </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1738083-bb"></a>destroy(<span class="bold"><strong>const</strong></span> pointer &amp; ptr) ;</pre>
<p>Destroys object. Throws if object's destructor throws </p>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id1738101-bb"></a>size(<span class="bold"><strong>const</strong></span> pointer &amp; p) <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </p>
</li>
<li><pre class="literallayout"><span class="type">std::pair&lt; pointer, <span class="bold"><strong>bool</strong></span> &gt;</span> 
<a name="id1738120-bb"></a>allocation_command(boost::interprocess::allocation_type command, 
                   size_type limit_size, size_type preferred_size, 
                   size_type &amp; received_size, <span class="bold"><strong>const</strong></span> pointer &amp; reuse = 0) ;</pre></li>
<li>
<pre class="literallayout"><span class="type">multiallocation_chain</span> 
<a name="id1738160-bb"></a>allocate_many(size_type elem_size, std::size_t num_elements) ;</pre>
<p>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </p>
</li>
<li>
<pre class="literallayout"><span class="type">multiallocation_chain</span> 
<a name="id1738187-bb"></a>allocate_many(<span class="bold"><strong>const</strong></span> size_type * elem_sizes, size_type n_elements) ;</pre>
<p>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1738212-bb"></a>deallocate_many(multiallocation_chain chain) ;</pre>
<p>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </p>
</li>
<li>
<pre class="literallayout"><span class="type">pointer</span> <a name="id1738234-bb"></a>allocate_one() ;</pre>
<p>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws boost::interprocess::bad_alloc if there is no enough memory </p>
</li>
<li>
<pre class="literallayout"><span class="type">multiallocation_chain</span> <a name="id1738248-bb"></a>allocate_individual(std::size_t num_elements) ;</pre>
<p>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1738271-bb"></a>deallocate_one(<span class="bold"><strong>const</strong></span> pointer &amp; p) ;</pre>
<p>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1738291-bb"></a>deallocate_individual(multiallocation_chain it) ;</pre>
<p>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </p>
</li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2005 - 2008 Ion Gaztañaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../../boost_interprocess_reference.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_interprocess_reference.html#header.boost.interprocess.allocators.adaptive_pool_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="adaptive_pool/rebind.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
