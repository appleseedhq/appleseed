<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template scoped_lock</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="../../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../../boost_interprocess_reference.html#header.boost.interprocess.sync.scoped_lock_hpp" title="Header &lt;boost/interprocess/sync/scoped_lock.hpp&gt;">
<link rel="prev" href="null_mutex.html" title="Class null_mutex">
<link rel="next" href="sharable_lock.html" title="Class template sharable_lock">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="null_mutex.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_interprocess_reference.html#header.boost.interprocess.sync.scoped_lock_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="sharable_lock.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.interprocess.scoped_lock"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template scoped_lock</span></h2>
<p>boost::interprocess::scoped_lock</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../../boost_interprocess_reference.html#header.boost.interprocess.sync.scoped_lock_hpp" title="Header &lt;boost/interprocess/sync/scoped_lock.hpp&gt;">boost/interprocess/sync/scoped_lock.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Mutex&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="scoped_lock.html" title="Class template scoped_lock">scoped_lock</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> Mutex <a name="boost.interprocess.scoped_lock.mutex_type"></a>mutex_type;

  <span class="emphasis"><em>// <a class="link" href="scoped_lock.html#boost.interprocess.scoped_lockconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="scoped_lock.html#id1775037-bb">scoped_lock</a>();
  <a class="link" href="scoped_lock.html#id1775043-bb">scoped_lock</a>(mutex_type &amp;);
  <a class="link" href="scoped_lock.html#id1775058-bb">scoped_lock</a>(mutex_type &amp;, <a class="link" href="defer_lock_type.html" title="Struct defer_lock_type">defer_lock_type</a>);
  <a class="link" href="scoped_lock.html#id1775077-bb">scoped_lock</a>(mutex_type &amp;, <a class="link" href="accept_ownership_type.html" title="Struct accept_ownership_type">accept_ownership_type</a>);
  <a class="link" href="scoped_lock.html#id1775097-bb">scoped_lock</a>(mutex_type &amp;, <a class="link" href="try_to_lock_type.html" title="Struct try_to_lock_type">try_to_lock_type</a>);
  <a class="link" href="scoped_lock.html#id1775121-bb">scoped_lock</a>(mutex_type &amp;, <span class="bold"><strong>const</strong></span> boost::posix_time::ptime &amp;);
  <a class="link" href="scoped_lock.html#id1775145-bb">scoped_lock</a>(<a class="link" href="scoped_lock.html" title="Class template scoped_lock">scoped_lock</a> &amp;&amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <a class="link" href="scoped_lock.html#id1775157-bb">scoped_lock</a>(<a class="link" href="upgradable_lock.html" title="Class template upgradable_lock">upgradable_lock</a>&lt; T &gt; &amp;&amp;, <span class="emphasis"><em>unspecified</em></span> = 0);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <a class="link" href="scoped_lock.html#id1775186-bb">scoped_lock</a>(<a class="link" href="upgradable_lock.html" title="Class template upgradable_lock">upgradable_lock</a>&lt; T &gt; &amp;&amp;, <a class="link" href="try_to_lock_type.html" title="Struct try_to_lock_type">try_to_lock_type</a>, <span class="emphasis"><em>unspecified</em></span> = 0);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <a class="link" href="scoped_lock.html#id1775221-bb">scoped_lock</a>(<a class="link" href="upgradable_lock.html" title="Class template upgradable_lock">upgradable_lock</a>&lt; T &gt; &amp;&amp;, boost::posix_time::ptime &amp;, 
                <span class="emphasis"><em>unspecified</em></span> = 0);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
    <a class="link" href="scoped_lock.html#id1775255-bb">scoped_lock</a>(<a class="link" href="sharable_lock.html" title="Class template sharable_lock">sharable_lock</a>&lt; T &gt; &amp;&amp;, <a class="link" href="try_to_lock_type.html" title="Struct try_to_lock_type">try_to_lock_type</a>, <span class="emphasis"><em>unspecified</em></span> = 0);
  scoped_lock&amp; <a class="link" href="scoped_lock.html#id1775297-bb"><span class="bold"><strong>operator</strong></span>=</a>(<a class="link" href="scoped_lock.html" title="Class template scoped_lock">scoped_lock</a> &amp;&amp;);
  <a class="link" href="scoped_lock.html#id1775290-bb">~scoped_lock</a>();

  <span class="emphasis"><em>// <a class="link" href="scoped_lock.html#id1774896-bb">public member functions</a></em></span>
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="scoped_lock.html#id1774900-bb">lock</a>() ;
  <span class="type">*<span class="bold"><strong>bool</strong></span></span> <a class="link" href="scoped_lock.html#id1774915-bb">try_lock</a>() ;
  <span class="type">*<span class="bold"><strong>bool</strong></span></span> <a class="link" href="scoped_lock.html#id1774934-bb">timed_lock</a>(<span class="bold"><strong>const</strong></span> boost::posix_time::ptime &amp;) ;
  <span class="type">*<span class="bold"><strong>void</strong></span></span> <a class="link" href="scoped_lock.html#id1774951-bb">unlock</a>() ;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="scoped_lock.html#id1774966-bb">owns</a>() <span class="bold"><strong>const</strong></span>;
  <a class="link" href="scoped_lock.html#id1774978-bb"><span class="bold"><strong>operator</strong></span> unspecified_bool_type</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">mutex_type *</span> <a class="link" href="scoped_lock.html#id1774991-bb">mutex</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">mutex_type *</span> <a class="link" href="scoped_lock.html#id1775003-bb">release</a>() ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="scoped_lock.html#id1775017-bb">swap</a>(<a class="link" href="scoped_lock.html" title="Class template scoped_lock">scoped_lock</a>&lt; mutex_type &gt; &amp;) ;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id2254990"></a><h2>Description</h2>
<p>scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (recursive or not) for the Mutex. The Mutex need not supply all of this functionality. If the client of scoped_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership transfer is supported through the syntax of move semantics. Ownership transfer is allowed both by construction and assignment. The scoped_lock does not support copy semantics. A compile time error results if copy construction or copy assignment is attempted. Mutex ownership can also be moved from an upgradable_lock and sharable_lock via constructor. In this role, scoped_lock shares the same functionality as a write_lock. </p>
<div class="refsect2" lang="en">
<a name="id2254999"></a><h3>
<a name="boost.interprocess.scoped_lockconstruct-copy-destruct"></a><code class="computeroutput">scoped_lock</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id1775037-bb"></a>scoped_lock();</pre>
<p>Effects: Default constructs a scoped_lock. Postconditions: owns() == false and mutex() == 0. </p>
</li>
<li>
<pre class="literallayout"><a name="id1775043-bb"></a>scoped_lock(mutex_type &amp; m);</pre>
<p>Effects: m.lock(). Postconditions: owns() == true and mutex() == &amp;m. Notes: The constructor will take ownership of the mutex. If another thread already owns the mutex, this thread will block until the mutex is released. Whether or not this constructor handles recursive locking depends upon the mutex. </p>
</li>
<li>
<pre class="literallayout"><a name="id1775058-bb"></a>scoped_lock(mutex_type &amp; m, <a class="link" href="defer_lock_type.html" title="Struct defer_lock_type">defer_lock_type</a>);</pre>
<p>Postconditions: owns() == false, and mutex() == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </p>
</li>
<li>
<pre class="literallayout"><a name="id1775077-bb"></a>scoped_lock(mutex_type &amp; m, <a class="link" href="accept_ownership_type.html" title="Struct accept_ownership_type">accept_ownership_type</a>);</pre>
<p>Postconditions: owns() == true, and mutex() == &amp;m. Notes: The constructor will suppose that the mutex is already locked. There is no effect required on the referenced mutex. </p>
</li>
<li>
<pre class="literallayout"><a name="id1775097-bb"></a>scoped_lock(mutex_type &amp; m, <a class="link" href="try_to_lock_type.html" title="Struct try_to_lock_type">try_to_lock_type</a>);</pre>
<p>Effects: m.try_lock(). Postconditions: mutex() == &amp;m. owns() == the return value of the m.try_lock() executed within the constructor. Notes: The constructor will take ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock, this constructor will fail at compile time if instantiated, but otherwise have no effect. </p>
</li>
<li>
<pre class="literallayout"><a name="id1775121-bb"></a>scoped_lock(mutex_type &amp; m, <span class="bold"><strong>const</strong></span> boost::posix_time::ptime &amp; abs_time);</pre>
<p>Effects: m.timed_lock(abs_time). Postconditions: mutex() == &amp;m. owns() == the return value of the m.timed_lock(abs_time) executed within the constructor. Notes: The constructor will take ownership of the mutex if it can do it until abs_time is reached. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock, this constructor will fail at compile time if instantiated, but otherwise have no effect. </p>
</li>
<li>
<pre class="literallayout"><a name="id1775145-bb"></a>scoped_lock(<a class="link" href="scoped_lock.html" title="Class template scoped_lock">scoped_lock</a> &amp;&amp; scop);</pre>
<p>Postconditions: mutex() == the value scop.mutex() had before the constructor executes. s1.mutex() == 0. owns() == the value of scop.owns() before the constructor executes. scop.owns(). Notes: If the scop scoped_lock owns the mutex, ownership is moved to thisscoped_lock with no blocking. If the scop scoped_lock does not own the mutex, then neither will this scoped_lock. Only a moved scoped_lock's will match this signature. An non-moved scoped_lock can be moved with the expression: "boost::interprocess::move(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <a name="id1775157-bb"></a>scoped_lock(<a class="link" href="upgradable_lock.html" title="Class template upgradable_lock">upgradable_lock</a>&lt; T &gt; &amp;&amp; upgr, <span class="emphasis"><em>unspecified</em></span> = 0);</pre>
<p>Effects: If upgr.owns() then calls unlock_upgradable_and_lock() on the referenced mutex. upgr.release() is called. Postconditions: mutex() == the value upgr.mutex() had before the construction. upgr.mutex() == 0. owns() == upgr.owns() before the construction. upgr.owns() == false after the construction. Notes: If upgr is locked, this constructor will lock this scoped_lock while unlocking upgr. If upgr is unlocked, then this scoped_lock will be unlocked as well. Only a moved upgradable_lock's will match this signature. An non-moved upgradable_lock can be moved with the expression: "boost::interprocess::move(lock);" This constructor may block if other threads hold a sharable_lock on this mutex (sharable_lock's can share ownership with an upgradable_lock). </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <a name="id1775186-bb"></a>scoped_lock(<a class="link" href="upgradable_lock.html" title="Class template upgradable_lock">upgradable_lock</a>&lt; T &gt; &amp;&amp; upgr, <a class="link" href="try_to_lock_type.html" title="Struct try_to_lock_type">try_to_lock_type</a>, <span class="emphasis"><em>unspecified</em></span> = 0);</pre>
<p>Effects: If upgr.owns() then calls try_unlock_upgradable_and_lock() on the referenced mutex: a)if try_unlock_upgradable_and_lock() returns true then mutex() obtains the value from upgr.release() and owns() is set to true. b)if try_unlock_upgradable_and_lock() returns false then upgr is unaffected and this scoped_lock construction as the same effects as a default construction. c)Else upgr.owns() is false. mutex() obtains the value from upgr.release() and owns() is set to false Notes: This construction will not block. It will try to obtain mutex ownership from upgr immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <a name="id1775221-bb"></a>scoped_lock(<a class="link" href="upgradable_lock.html" title="Class template upgradable_lock">upgradable_lock</a>&lt; T &gt; &amp;&amp; upgr, 
              boost::posix_time::ptime &amp; abs_time, <span class="emphasis"><em>unspecified</em></span> = 0);</pre>
<p>Effects: If upgr.owns() then calls timed_unlock_upgradable_and_lock(abs_time) on the referenced mutex: a)if timed_unlock_upgradable_and_lock(abs_time) returns true then mutex() obtains the value from upgr.release() and owns() is set to true. b)if timed_unlock_upgradable_and_lock(abs_time) returns false then upgr is unaffected and this scoped_lock construction as the same effects as a default construction. c)Else upgr.owns() is false. mutex() obtains the value from upgr.release() and owns() is set to false Notes: This construction will not block. It will try to obtain mutex ownership from upgr immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; 
  <a name="id1775255-bb"></a>scoped_lock(<a class="link" href="sharable_lock.html" title="Class template sharable_lock">sharable_lock</a>&lt; T &gt; &amp;&amp; shar, <a class="link" href="try_to_lock_type.html" title="Struct try_to_lock_type">try_to_lock_type</a>, <span class="emphasis"><em>unspecified</em></span> = 0);</pre>
<p>Effects: If shar.owns() then calls try_unlock_sharable_and_lock() on the referenced mutex. a)if try_unlock_sharable_and_lock() returns true then mutex() obtains the value from shar.release() and owns() is set to true. b)if try_unlock_sharable_and_lock() returns false then shar is unaffected and this scoped_lock construction has the same effects as a default construction. c)Else shar.owns() is false. mutex() obtains the value from shar.release() and owns() is set to false Notes: This construction will not block. It will try to obtain mutex ownership from shar immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </p>
</li>
<li>
<pre class="literallayout">scoped_lock&amp; <a name="id1775297-bb"></a><span class="bold"><strong>operator</strong></span>=(<a class="link" href="scoped_lock.html" title="Class template scoped_lock">scoped_lock</a> &amp;&amp; scop);</pre>
<p>Effects: If owns() before the call, then unlock() is called on mutex(). this gets the state of scop and scop gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and scop own the same mutex before the assignment. In this case, this will own the mutex after the assignment (and scop will not), but the mutex's lock count will be decremented by one. </p>
</li>
<li>
<pre class="literallayout"><a name="id1775290-bb"></a>~scoped_lock();</pre>
<p>Effects: if (owns()) mp_mutex-&gt;unlock(). Notes: The destructor behavior ensures that the mutex lock is not leaked. </p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id2255408"></a><h3>
<a name="id1774896-bb"></a><code class="computeroutput">scoped_lock</code> public member functions</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1774900-bb"></a>lock() ;</pre>
<p>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls lock() on the referenced mutex. Postconditions: owns() == true. Notes: The scoped_lock changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </p>
</li>
<li>
<pre class="literallayout"><span class="type">*<span class="bold"><strong>bool</strong></span></span> <a name="id1774915-bb"></a>try_lock() ;</pre>
<p>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls try_lock() on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;try_lock(). Notes: The scoped_lock changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support try_lock(), this function will fail at compile time if instantiated, but otherwise have no effect. </p>
</li>
<li>
<pre class="literallayout"><span class="type">*<span class="bold"><strong>bool</strong></span></span> <a name="id1774934-bb"></a>timed_lock(<span class="bold"><strong>const</strong></span> boost::posix_time::ptime &amp; abs_time) ;</pre>
<p>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls timed_lock(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt; timed_lock(abs_time). Notes: The scoped_lock changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership by the specified time. If the mutex_type does not support timed_lock (), this function will fail at compile time if instantiated, but otherwise have no effect. </p>
</li>
<li>
<pre class="literallayout"><span class="type">*<span class="bold"><strong>void</strong></span></span> <a name="id1774951-bb"></a>unlock() ;</pre>
<p>Effects: If mutex() == 0 or if not locked, throws a lock_exception() exception. Calls unlock() on the referenced mutex. Postconditions: owns() == false. Notes: The scoped_lock changes from a state of owning the mutex, to not owning the mutex. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id1774966-bb"></a>owns() <span class="bold"><strong>const</strong></span>;</pre>
<p>Effects: Returns true if this scoped_lock has acquired the referenced mutex. </p>
</li>
<li>
<pre class="literallayout"><a name="id1774978-bb"></a><span class="bold"><strong>operator</strong></span> unspecified_bool_type() <span class="bold"><strong>const</strong></span>;</pre>
<p>Conversion to bool. Returns owns(). </p>
</li>
<li>
<pre class="literallayout"><span class="type">mutex_type *</span> <a name="id1774991-bb"></a>mutex() <span class="bold"><strong>const</strong></span>;</pre>
<p>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </p>
</li>
<li>
<pre class="literallayout"><span class="type">mutex_type *</span> <a name="id1775003-bb"></a>release() ;</pre>
<p>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: mutex() == 0 and owns() == false. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1775017-bb"></a>swap(<a class="link" href="scoped_lock.html" title="Class template scoped_lock">scoped_lock</a>&lt; mutex_type &gt; &amp; other) ;</pre>
<p>Effects: Swaps state with moved lock. Throws: Nothing. </p>
</li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2005 - 2008 Ion Gaztañaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="null_mutex.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_interprocess_reference.html#header.boost.interprocess.sync.scoped_lock_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="sharable_lock.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
